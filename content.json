{"pages":[{"title":"关于我","text":"个人简介 90后的程序员一枚，想要把所有让我一开始觉得困惑的技术弄懂，崇拜大牛，喜欢打游戏，写博客，钻研技术。 个人寄语 no code，no bb","link":"/about/index.html"}],"posts":[{"title":"java计算两个时间之间相差月份","text":"记录一下java计算两个时间相差的月份 public static Integer getDifMonth(Date startDate, Date endDate){ Calendar start = Calendar.getInstance(); Calendar end = Calendar.getInstance(); start.setTime(startDate); end.setTime(endDate); int result = end.get(Calendar.MONTH) - start.get(Calendar.MONTH); int month = (end.get(Calendar.YEAR) - start.get(Calendar.YEAR)) * 12; return Math.abs(month + result); }","link":"/java/utils/diff-time/"},{"title":"hive简介及安装","text":"hive是基于Hadoop的一个数据仓库工具，用来进行数据提取、转化、加载，这是一种可以存储、查询和分析存储在Hadoop中的大规模数据的机制。hive数据仓库工具能将结构化的数据文件映射为一张数据库表，并提供SQL查询功能，能将SQL语句转变成MapReduce任务来执行。Hive的优点是学习成本低，可以通过类似SQL语句实现快速MapReduce统计，使MapReduce变得更加简单，而不必开发专门的MapReduce应用程序。hive十分适合对数据仓库进行统计分析。 hive的安装（mac版本） 环境 操作系统：macOS Big Sur版本：11.2.3","link":"/bigdata/hive1/"},{"title":"docker简介及安装","text":"什么是dockerDocker 是一个开源的应用容器引擎，基于 Go 语言并遵从 Apache2.0 协议开源。 Docker 可以让开发者打包他们的应用以及依赖包到一个轻量级、可移植的容器中，然后发布到任何流行的 Linux 机器上，也可以实现虚拟化。 容器是完全使用沙箱机制，相互之间不会有任何接口（类似 iPhone 的 app）,更重要的是容器性能开销极低。 docker与传统的虚拟机有什么区别 vm与docker框架，直观上来讲vm多了一层guest OS，同时Hypervisor会对硬件资源进行虚拟化，docker直接使用硬件资源，所以资源利用率相对docker低也是比较容易理解的 docker的安装与常见问题环境 操作系统：macos 10.15.6 窗口：iTerm2 工具包：homebrew 安装 打开iterm窗口 输入命令 brew cask install docker 等待docker安装完成 docker安装完成之后在启动台中会有docker启动项 打开docker，第一启动会有点慢，甚至可能会出现一直staring的现象，一会说一下解决办法 更换国内镜像 打开preferences-&gt;docker engine {&quot;experimental&quot;:true,&quot;debug&quot;:true,&quot;registry-mirrors&quot;:[ &quot;https://docker.mirrors.ustc.edu.cn&quot; ]} 重启docker docker初始化一直starting的解决办法点击preference，打开右上角小虫子形状的按钮，点击clean/purge data，稍等一会看问题是否可以解决，笔者是通过这种方式解决的问题","link":"/tool/docker/docker-install/"},{"title":"docker基本命令","text":"本文将介绍一些docker中的命令与目前过程中的一些技巧,这是自己在学习过程中的一些积累，记录下来，方便查询。 docker 命令大全帮助命令docker version --显示docker的版本号docker info --显示docker的详细信息docker &lt;命令行&gt; --help 帮助命令 docker命令行地址：https://docs.docker.com/engine/reference/run/ 镜像命令 docker images 列出镜像 ➜ ~ docker images --helpUsage: docker images [OPTIONS] [REPOSITORY[:TAG]]List imagesOptions: -a, --all Show all images (default hides intermediate images) --digests Show digests -f, --filter filter Filter output based on conditions provided --format string Pretty-print images using a Go template --no-trunc Don't truncate output -q, --quiet Only show image IDs➜ ~ docker imagesREPOSITORY TAG IMAGE ID CREATED SIZEmysql latest ab2f358b8612 4 months ago 545MBzookeeper latest ea93faa92337 4 months ago 253MBredis latest 84c5f6e03bf0 7 months ago 104MBnginx latest 7e4d58f0e5f3 7 months ago 133MB# 解释REPOSITORY：镜像的仓库源TAG：镜像标签IMAGE ID：镜像idCREATED：创建时间SIZE：镜像大小 docker search 搜索镜像 ➜ ~ docker search --helpUsage: docker search [OPTIONS] TERMSearch the Docker Hub for imagesOptions: -f, --filter filter Filter output based on conditions provided --format string Pretty-print search using a Go template --limit int Max number of search results (default 25) --no-trunc Don't truncate output➜ ~ docker search mysqlNAME DESCRIPTION STARS OFFICIAL AUTOMATEDmysql MySQL is a widely used, open-source relation… 10743 [OK]mariadb MariaDB Server is a high performing open sou… 4046 [OK]mysql/mysql-server Optimized MySQL Server Docker images. Create… 790 [OK]percona Percona Server is a fork of the MySQL relati… 532 [OK]centos/mysql-57-centos7 MySQL 5.7 SQL database server 87mysql/mysql-cluster Experimental MySQL Cluster Docker images. Cr… 81centurylink/mysql Image containing mysql. Optimized to be link… 59 [OK]bitnami/mysql Bitnami MySQL Docker Image 50 [OK]databack/mysql-backup Back up mysql databases to... anywhere! 42deitch/mysql-backup REPLACED! Please use http://hub.docker.com/r… 41 [OK]prom/mysqld-exporter 37 [OK]tutum/mysql Base docker image to run a MySQL database se… 35schickling/mysql-backup-s3 Backup MySQL to S3 (supports periodic backup… 29 [OK]linuxserver/mysql A Mysql container, brought to you by LinuxSe… 27centos/mysql-56-centos7 MySQL 5.6 SQL database server 20circleci/mysql MySQL is a widely used, open-source relation… 20mysql/mysql-router MySQL Router provides transparent routing be… 19arey/mysql-client Run a MySQL client from a docker container 17 [OK]fradelg/mysql-cron-backup MySQL/MariaDB database backup using cron tas… 12 [OK]yloeffler/mysql-backup This image runs mysqldump to backup data usi… 7 [OK]openshift/mysql-55-centos7 DEPRECATED: A Centos7 based MySQL v5.5 image… 6devilbox/mysql Retagged MySQL, MariaDB and PerconaDB offici… 3ansibleplaybookbundle/mysql-apb An APB which deploys RHSCL MySQL 2 [OK]jelastic/mysql An image of the MySQL database server mainta… 1widdpim/mysql-client Dockerized MySQL Client (5.7) including Curl… 1 [OK]➜ ~ docker search --filter=stars=3000 mysqlNAME DESCRIPTION STARS OFFICIAL AUTOMATEDmysql MySQL is a widely used, open-source relation… 10743 [OK]mariadb MariaDB Server is a high performing open sou… 4046 [OK]# 重要的可以filterdocker search --filter=stars=3000 mysql docker pull 拉取 ➜ ~ docker pull mysqlUsing default tag: latest# docker 默认拉取最新的版本号latest: Pulling from library/mysqlf7ec5a41d630: Pull complete9444bb562699: Pull complete6a4207b96940: Pull complete181cefd361ce: Pull complete8a2090759d8a: Pull complete15f235e0d7ee: Pull completed870539cd9db: Pull complete5726073179b6: Pull completeeadfac8b2520: Pull completef5936a8c3f2b: Pull completecca8ee89e625: Pull complete6c79df02586a: Pull completeDigest: sha256:6e0014cdd88092545557dee5e9eb7e1a3c84c9a14ad2418d5f2231e930967a38Status: Downloaded newer image for mysql:latestdocker.io/library/mysql:latest➜ ~ docker pull mysql:5.7# 指定版本号，拉取版本号的镜像5.7: Pulling from library/mysqlf7ec5a41d630: Already exists9444bb562699: Already exists6a4207b96940: Already exists181cefd361ce: Already exists8a2090759d8a: Already exists15f235e0d7ee: Already existsd870539cd9db: Already exists## docker采用分层的思想，把一个完整的镜像拆分，如果之前下载过某些分层，则不需要重新下载7310c448ab4f: Pull complete4a72aac2e800: Pull completeb1ab932f17c4: Pull complete1a985de740ee: Pull completeDigest: sha256:e42a18d0bd0aa746a734a49cbbcc079ccdf6681c474a238d38e79dc0884e0eccStatus: Downloaded newer image for mysql:5.7docker.io/library/mysql:5.7 docker rmi -f 删除镜像 ➜ ~ docker rmi --helpUsage: docker rmi [OPTIONS] IMAGE [IMAGE...]Remove one or more imagesOptions: -f, --force Force removal of the image --no-prune Do not delete untagged parents# 删除指定的镜像➜ ~docker rmi -f daaaaaaaa# 递归删除全部镜像➜ ~docker rmi -f $(docker images -aq) 容器命令有了镜像才能有容器 docker run 运行命令 ➜ ~ docker run --helpUsage: docker run [OPTIONS] IMAGE [COMMAND] [ARG...]Run a command in a new containerOptions: --add-host list Add a custom host-to-IP mapping (host:ip) -a, --attach list Attach to STDIN, STDOUT or STDERR --blkio-weight uint16 Block IO (relative weight), between 10 and 1000, or 0 to disable (default 0) --blkio-weight-device list Block IO weight (relative device weight) (default []) --cap-add list Add Linux capabilities --cap-drop list Drop Linux capabilities --cgroup-parent string Optional parent cgroup for the container --cgroupns string Cgroup namespace to use (host|private) 'host': Run the container in the Docker host's cgroup namespace 'private': Run the container in its own private cgroup namespace '': Use the cgroup namespace as configured by the default-cgroupns-mode option on the daemon (default) --cidfile string Write the container ID to the file --cpu-period int Limit CPU CFS (Completely Fair Scheduler) period --cpu-quota int Limit CPU CFS (Completely Fair Scheduler) quota --cpu-rt-period int Limit CPU real-time period in microseconds --cpu-rt-runtime int Limit CPU real-time runtime in microseconds -c, --cpu-shares int CPU shares (relative weight) --cpus decimal Number of CPUs --cpuset-cpus string CPUs in which to allow execution (0-3, 0,1) --cpuset-mems string MEMs in which to allow execution (0-3, 0,1) -d, --detach Run container in background and print container ID --detach-keys string Override the key sequence for detaching a container --device list Add a host device to the container --device-cgroup-rule list Add a rule to the cgroup allowed devices list --device-read-bps list Limit read rate (bytes per second) from a device (default []) --device-read-iops list Limit read rate (IO per second) from a device (default []) --device-write-bps list Limit write rate (bytes per second) to a device (default []) --device-write-iops list Limit write rate (IO per second) to a device (default []) --disable-content-trust Skip image verification (default true) --dns list Set custom DNS servers --dns-option list Set DNS options --dns-search list Set custom DNS search domains --domainname string Container NIS domain name --entrypoint string Overwrite the default ENTRYPOINT of the image -e, --env list Set environment variables --env-file list Read in a file of environment variables --expose list Expose a port or a range of ports --gpus gpu-request GPU devices to add to the container ('all' to pass all GPUs) --group-add list Add additional groups to join --health-cmd string Command to run to check health --health-interval duration Time between running the check (ms|s|m|h) (default 0s) --health-retries int Consecutive failures needed to report unhealthy --health-start-period duration Start period for the container to initialize before starting health-retries countdown (ms|s|m|h) (default 0s) --health-timeout duration Maximum time to allow one check to run (ms|s|m|h) (default 0s) --help Print usage -h, --hostname string Container host name --init Run an init inside the container that forwards signals and reaps processes -i, --interactive Keep STDIN open even if not attached --ip string IPv4 address (e.g., 172.30.100.104) --ip6 string IPv6 address (e.g., 2001:db8::33) --ipc string IPC mode to use --isolation string Container isolation technology --kernel-memory bytes Kernel memory limit -l, --label list Set meta data on a container --label-file list Read in a line delimited file of labels --link list Add link to another container --link-local-ip list Container IPv4/IPv6 link-local addresses --log-driver string Logging driver for the container --log-opt list Log driver options --mac-address string Container MAC address (e.g., 92:d0:c6:0a:29:33) -m, --memory bytes Memory limit --memory-reservation bytes Memory soft limit --memory-swap bytes Swap limit equal to memory plus swap: '-1' to enable unlimited swap --memory-swappiness int Tune container memory swappiness (0 to 100) (default -1) --mount mount Attach a filesystem mount to the container --name string Assign a name to the container --network network Connect a container to a network --network-alias list Add network-scoped alias for the container --no-healthcheck Disable any container-specified HEALTHCHECK --oom-kill-disable Disable OOM Killer --oom-score-adj int Tune host's OOM preferences (-1000 to 1000) --pid string PID namespace to use --pids-limit int Tune container pids limit (set -1 for unlimited) --platform string Set platform if server is multi-platform capable --privileged Give extended privileges to this container -p, --publish list Publish a container's port(s) to the host -P, --publish-all Publish all exposed ports to random ports --pull string Pull image before running (&quot;always&quot;|&quot;missing&quot;|&quot;never&quot;) (default &quot;missing&quot;) --read-only Mount the container's root filesystem as read only --restart string Restart policy to apply when a container exits (default &quot;no&quot;) --rm Automatically remove the container when it exits --runtime string Runtime to use for this container --security-opt list Security Options --shm-size bytes Size of /dev/shm --sig-proxy Proxy received signals to the process (default true) --stop-signal string Signal to stop a container (default &quot;SIGTERM&quot;) --stop-timeout int Timeout (in seconds) to stop a container --storage-opt list Storage driver options for the container --sysctl map Sysctl options (default map[]) --tmpfs list Mount a tmpfs directory -t, --tty Allocate a pseudo-TTY --ulimit ulimit Ulimit options (default []) -u, --user string Username or UID (format: &lt;name|uid&gt;[:&lt;group|gid&gt;]) --userns string User namespace to use --uts string UTS namespace to use -v, --volume list Bind mount a volume --volume-driver string Optional volume driver for the container --volumes-from list Mount volumes from the specified container(s) -w, --workdir string Working directory inside the container 下面我们拿几个常用的参数解释 --name 指定运行容器的名字-d 后台方式-it 使用交互方式 进入容器查看-p 指定容器的端口-P 随机指定端口 测试一下 ➜ ~ docker run --name centos1 -itd 300e315adb2fc1c9a9a26dd33a6392487db1f2a7c960332eac309413a4fa82e9d9f30b4ec3fe➜ ~ docker psCONTAINER ID IMAGE COMMAND CREATED STATUS PORTS NAMESc1c9a9a26dd3 300e315adb2f &quot;/bin/bash&quot; 5 seconds ago Up 4 seconds centos1➜ ~ docker exec -it centos1 /bin/bash[root@c1c9a9a26dd3 /]# lsbin dev etc home lib lib64 lost+found media mnt opt proc root run sbin srv sys tmp usr var[root@c1c9a9a26dd3 /]# pwd/[root@c1c9a9a26dd3 /]# whereis nginxnginx: docker技巧 docker容器访问宿主机的地址 宿主机地址为：host.docker.internal","link":"/docker/command/"},{"title":"单例模式","text":"单例模式（Singleton Pattern）是 Java 中最简单的设计模式之一。这种类型的设计模式属于创建型模式，它提供了一种创建对象的最佳方式。这种模式涉及到一个单一的类，该类负责创建自己的对象，同时确保只有单个对象被创建。这个类提供了一种访问其唯一的对象的方式，可以直接访问，不需要实例化该类的对象。 介绍意图：保证一个类仅有一个实例，并提供一个访问它的全局访问点。 主要解决：一个全局使用的类频繁地创建与销毁。 何时使用：当您想控制实例数目，节省系统资源的时候。 如何解决：判断系统是否已经有这个单例，如果有则返回，如果没有则创建。 关键代码：构造函数是私有的。 应用实例： 1、一个班级只有一个班主任。2、Windows 是多进程多线程的，在操作一个文件的时候，就不可避免地出现多个进程或线程同时操作一个文件的现象，所以所有文件的处理必须通过唯一的实例来进行。3、一些设备管理器常常设计为单例模式，比如一个电脑有两台打印机，在输出的时候就要处理不能两台打印机打印同一个文件。优点： 1、在内存里只有一个实例，减少了内存的开销，尤其是频繁的创建和销毁实例（比如管理学院首页页面缓存）。2、避免对资源的多重占用（比如写文件操作）。缺点：没有接口，不能继承，与单一职责原则冲突，一个类应该只关心内部逻辑，而不关心外面怎么样来实例化。 使用场景： 1、要求生产唯一序列号。2、WEB 中的计数器，不用每次刷新都在数据库里加一次，用单例先缓存起来。3、创建的一个对象需要消耗的资源过多，比如 I/O 与数据库的连接等。注意事项：getInstance() 方法中需要使用同步锁 synchronized (Singleton.class) 防止多线程同时进入造成 instance 被多次实例化。 几种单例模式的创建方式懒汉模式（线程不安全）public class Singleton { private static Singleton instance; private Singleton (){} public static Singleton getInstance() { if (instance == null) { instance = new Singleton(); } return instance; } } 懒汉模式（线程安全）public class Singleton { private static Singleton instance; private Singleton (){} public static synchronized Singleton getInstance() { if (instance == null) { instance = new Singleton(); } return instance; } } 饿汉模式线程是否安全：是优点：没有加锁，执行效率高缺点：类加载时就初始化，浪费内存 public class Singleton { private static Singleton instance = new Singleton(); private Singleton (){} public static Singleton getInstance() { return instance; } } 双检锁/双重校验锁public class Singleton { private volatile static Singleton singleton; private Singleton (){} public static Singleton getSingleton() { if (singleton == null) { synchronized (Singleton.class) { if (singleton == null) { singleton = new Singleton(); } } } return singleton; } } 登记式/静态内部类public class Singleton { private static class SingletonHolder { private static final Singleton INSTANCE = new Singleton(); } private Singleton (){} public static final Singleton getInstance() { return SingletonHolder.INSTANCE; } } 参考 菜鸟教程-单例模式","link":"/design-pattern/singleton/"},{"title":"原型模式","text":"在有些系统中，存在大量相同或相似对象的创建问题，如果用传统的构造函数来创建对象，会比较复杂且耗时耗资源，用原型模式生成对象就很高效，就像孙悟空拔下猴毛轻轻一吹就变出很多孙悟空一样简单。 原型模式的定义与特点原型（Prototype）模式的定义如下：用一个已经创建的实例作为原型，通过复制该原型对象来创建一个和原型相同或相似的新对象。在这里，原型实例指定了要创建的对象的种类。用这种方式创建对象非常高效，根本无须知道对象创建的细节。例如，Windows 操作系统的安装通常较耗时，如果复制就快了很多。在生活中复制的例子非常多，这里不一一列举了。 原型模式的优点： Java 自带的原型模式基于内存二进制流的复制，在性能上比直接 new 一个对象更加优良。 可以使用深克隆方式保存对象的状态，使用原型模式将对象复制一份，并将其状态保存起来，简化了创建对象的过程，以便在需要的时候使用（例如恢复到历史某一状态），可辅助实现撤销操作。 原型模式的缺点： 需要为每一个类都配置一个 clone 方法 clone 方法位于类的内部，当对已有类进行改造的时候，需要修改代码，违背了开闭原则。 当实现深克隆时，需要编写较为复杂的代码，而且当对象之间存在多重嵌套引用时，为了实现深克隆，每一层对象对应的类都必须支持深克隆，实现起来会比较麻烦。因此，深克隆、浅克隆需要运用得当。 原型模式的结构与实现由于 Java 提供了对象的 clone() 方法，所以用 Java 实现原型模式很简单。 1. 模式的结构原型模式包含以下主要角色。 抽象原型类：规定了具体原型对象必须实现的接口。 具体原型类：实现抽象原型类的 clone() 方法，它是可被复制的对象。 访问类：使用具体原型类中的 clone() 方法来复制新的对象。 代码public class Realizetype implements Cloneable{ Realizetype() { System.out.println(&quot;具体原型创建成功！&quot;); } @Override public Realizetype clone() throws CloneNotSupportedException { return (Realizetype)super.clone(); }} public class PrototypeTest { public static void main(String[] args) throws CloneNotSupportedException { Realizetype obj1 = new Realizetype(); Realizetype obj2 = (Realizetype) obj1.clone(); System.out.println(&quot;obj1==obj2?&quot; + (obj1 == obj2)); }}","link":"/design-pattern/prototype/"},{"title":"工厂模式","text":"介绍一下简单工厂、工厂方法、抽象工厂模式 一、简单工厂模式 定义 定义一个工厂类，他可以根据不同的参数，创建不同的实例。众多实例之间有着共同的父类或者接口。实现此功能的方法一般为静态方法 优点 需要什么，仅仅需要传入一个或者多个参数，就能获取到实例，而无需知道其内部的实现过程 ==在简单工厂模式中，用于创建实例的方法通常为静态方法（static），因此简单工厂模式又被成为 静态工厂方法== 代码 package simple;/** * @author mrhy * @date 2021/1/2 09:37 * Copyright (C), 2018-2021 */public class BaoShiJie implements Car { @Override public String name() { return &quot;我是保时捷&quot;; }} package simple;/** * 兰博基尼 * * @author mrhy * @date 2021/1/2 09:38 * Copyright (C), 2018-2021 */public class LanBoJiNi implements Car { @Override public String name() { return &quot;我是兰博基尼&quot;; }} package simple;/** * 汽车接口 * * @author mrhy * @date 2021/1/2 09:36 * Copyright (C), 2018-2021 */public interface Car { String name();} package simple;/** * 汽车工厂 * * @author mrhy * @date 2021/1/2 09:39 * Copyright (C), 2018-2021 */public class CarFactory { public static Car createCar(String name) { if (&quot;lanbo&quot;.equals(name)) { return new LanBoJiNi(); } else if (&quot;baoshijie&quot;.equals(name)) { return new BaoShiJie(); } else { throw new RuntimeException(&quot;未找到车&quot;); } } public static void main(String[] args) { Car lanbo = CarFactory.createCar(&quot;lanbo&quot;); System.out.println(lanbo.name()); Car baoshijie = CarFactory.createCar(&quot;baoshijie&quot;); System.out.println(baoshijie.name()); }} 二、工厂方法模式 定义 工厂方法模式（FACTORY METHOD）是一种常用的类创建型设计模式,此模式的核心精神是封装类中变化的部分，提取其中个性化善变的部分为独立类，通过依赖注入以达到解耦、复用和方便后期维护拓展的目的。它的核心结构有四个角色，分别是抽象工厂；具体工厂；抽象产品；具体产品 优点 封装内部的实现过程，便于拓展 uml图 代码 package factorymethod;/** * 汽车接口 * * @author mrhy * @date 2021/1/2 09:36 * Copyright (C), 2018-2021 */public interface Car { String name();} package factorymethod;/** * 工厂方法的抽象类 * * @author mrhy * @date 2021/1/3 10:15 * Copyright (C), 2018-2021 */public interface Factory { Car newCar();} package factorymethod;/** * @author mrhy * @date 2021/1/2 09:37 * Copyright (C), 2018-2021 */public class BaoShiJie implements Car { @Override public String name() { return &quot;我是保时捷&quot;; }} package factorymethod;import simple.CarFactory;/** * 汽车工厂 * * @author mrhy * @date 2021/1/2 09:39 * Copyright (C), 2018-2021 */public class BaoshijieCarFactory implements Factory { @Override public Car newCar() { return new BaoShiJie(); }} package factorymethod;/** * @author mrhy * @date 2021/1/3 10:21 * Copyright (C), 2018-2021 */public class LanboCarFactory implements Factory { @Override public Car newCar() { return new LanBoJiNi(); } public static void main(String[] args) { Car baoshijie = new BaoshijieCarFactory().newCar(); System.out.println(baoshijie.name()); LanboCarFactory lanboCarFactory = new LanboCarFactory(); System.out.println(lanboCarFactory.newCar().name()); }} package factorymethod;/** * 兰博基尼 * * @author mrhy * @date 2021/1/2 09:38 * Copyright (C), 2018-2021 */public class LanBoJiNi implements Car { @Override public String name() { return &quot;我是兰博基尼&quot;; }} 三、抽象工厂模式 定义 工厂的工厂，主要面对的对象为产品族 uml 代码 package abstractfactory;/** * @author mrhy * @date 2021/1/4 13:54 * Copyright (C), 2018-2021 */public class Customer { public static void main(String[] args) { MiFactory miFactory = new MiFactory(); Phone phone = miFactory.getPhone(); phone.open(); phone.close(); phone.sendMsg(); phone.call(); Router router = miFactory.getRouter(); router.open(); router.close(); router.sendSgn(); HuaweiFactory huaweiFactory = new HuaweiFactory(); Phone phone2 = huaweiFactory.getPhone(); phone2.open(); phone2.close(); phone2.sendMsg(); phone2.call(); Router router2 = huaweiFactory.getRouter(); router2.open(); router2.close(); router2.sendSgn(); }} package abstractfactory;/** * @author mrhy * @date 2021/1/4 13:53 * Copyright (C), 2018-2021 */public class HuaweiFactory implements IFactory { @Override public Phone getPhone() { return new HuaweiIPhone(); } @Override public Router getRouter() { return new HuaWeiRouter(); }} package abstractfactory;/** * 小米手机 * * @author mrhy * @date 2021/1/4 09:50 * Copyright (C), 2018-2021 */public class HuaweiIPhone implements Phone{ @Override public void open() { System.out.println(&quot;华为手机开机&quot;); } @Override public void close() { System.out.println(&quot;华为手机关机&quot;); } @Override public void sendMsg() { System.out.println(&quot;华为手机发短信&quot;); } @Override public void call() { System.out.println(&quot;华为手机打电话&quot;); }} package abstractfactory;/** * @author mrhy * @date 2021/1/4 11:19 * Copyright (C), 2018-2021 */public class HuaWeiRouter implements Router { @Override public void open() { System.out.println(&quot;华为路由器开机&quot;); } @Override public void close() { System.out.println(&quot;华为路由器关闭&quot;); } @Override public void sendSgn() { System.out.println(&quot;华为路由器广播&quot;); }} package abstractfactory;/** * 工厂的基类接口 * * @author mrhy * @date 2021/1/4 13:50 * Copyright (C), 2018-2021 */public interface IFactory { Phone getPhone(); Router getRouter();} package abstractfactory;/** * 小米工厂 * * @author mrhy * @date 2021/1/4 13:52 * Copyright (C), 2018-2021 */public class MiFactory implements IFactory { @Override public Phone getPhone() { return new XiaomiIPhone(); } @Override public Router getRouter() { return new XiaomiRouter(); }} package abstractfactory;/** * 手机接口 * * @author mrhy * @date 2021/1/4 09:44 * Copyright (C), 2018-2021 */public interface Phone { void open(); void close(); void sendMsg(); void call();} package abstractfactory;/** * 路由器 * * @author mrhy * @date 2021/1/4 09:49 * Copyright (C), 2018-2021 */public interface Router { void open(); void close(); void sendSgn();} package abstractfactory;/** * 小米手机 * * @author mrhy * @date 2021/1/4 09:50 * Copyright (C), 2018-2021 */public class XiaomiIPhone implements Phone{ @Override public void open() { System.out.println(&quot;小米手机开机&quot;); } @Override public void close() { System.out.println(&quot;小米手机关机&quot;); } @Override public void sendMsg() { System.out.println(&quot;小米手机发短信&quot;); } @Override public void call() { System.out.println(&quot;小米手机打电话&quot;); }} package abstractfactory;/** * @author mrhy * @date 2021/1/4 11:19 * Copyright (C), 2018-2021 */public class XiaomiRouter implements Router { @Override public void open() { System.out.println(&quot;小米路由器开机&quot;); } @Override public void close() { System.out.println(&quot;小米路由器关闭&quot;); } @Override public void sendSgn() { System.out.println(&quot;小米路由器广播&quot;); }} package abstractfactory;/** * @author mrhy * @date 2021/1/4 13:54 * Copyright (C), 2018-2021 */public class Customer { public static void main(String[] args) { MiFactory miFactory = new MiFactory(); Phone phone = miFactory.getPhone(); phone.open(); phone.close(); phone.sendMsg(); phone.call(); Router router = miFactory.getRouter(); router.open(); router.close(); router.sendSgn(); HuaweiFactory huaweiFactory = new HuaweiFactory(); Phone phone2 = huaweiFactory.getPhone(); phone2.open(); phone2.close(); phone2.sendMsg(); phone2.call(); Router router2 = huaweiFactory.getRouter(); router2.open(); router2.close(); router2.sendSgn(); }}","link":"/design-pattern/factory/"},{"title":"建造者模式","text":"在软件开发过程中有时需要创建一个复杂的对象，这个复杂对象通常由多个子部件按一定的步骤组合而成。例如，计算机是由 CPU、主板、内存、硬盘、显卡、机箱、显示器、键盘、鼠标等部件组装而成的，采购员不可能自己去组装计算机，而是将计算机的配置要求告诉计算机销售公司，计算机销售公司安排技术人员去组装计算机，然后再交给要买计算机的采购员。 生活中这样的例子很多，如游戏中的不同角色，其性别、个性、能力、脸型、体型、服装、发型等特性都有所差异；还有汽车中的方向盘、发动机、车架、轮胎等部件也多种多样；每封电子邮件的发件人、收件人、主题、内容、附件等内容也各不相同。 以上所有这些产品都是由多个部件构成的，各个部件可以灵活选择，但其创建步骤都大同小异。这类产品的创建无法用前面介绍的工厂模式描述，只有建造者模式可以很好地描述该类产品的创建。 模型的定义及特点建造者（Builder）模式的定义：指将一个复杂对象的构造与它的表示分离，使同样的构建过程可以创建不同的表示，这样的设计模式被称为建造者模式。它是将一个复杂的对象分解为多个简单的对象，然后一步一步构建而成。它将变与不变相分离，即产品的组成部分是不变的，但每一部分是可以灵活选择的。 该模式的主要优点如下： 封装性好，构建和表示分离。 扩展性好，各个具体的建造者相互独立，有利于系统的解耦。 客户端不必知道产品内部组成的细节，建造者可以对创建过程逐步细化，而不对其它模块产生任何影响，便于控制细节风险。其缺点如下： 产品的组成部分必须相同，这限制了其使用范围。 如果产品的内部变化复杂，如果产品内部发生变化，则建造者也要同步修改，后期维护成本较大。 建造者（Builder）模式和工厂模式的关注点不同：建造者模式注重零部件的组装过程，而工厂方法模式更注重零部件的创建过程，但两者可以结合使用。 角色 产品角色（Product）：它是包含多个组成部件的复杂对象，由具体建造者来创建其各个零部件。 抽象建造者（Builder）：它是一个包含创建产品各个子部件的抽象方法的接口，通常还包含一个返回复杂产品的方法 getResult()。 具体建造者(Concrete Builder）：实现 Builder 接口，完成复杂产品的各个部件的具体创建方法。 指挥者（Director）：它调用建造者对象中的部件构造与装配方法完成复杂对象的创建，在指挥者中不涉及具体产品的信息。 代码组成部分（子部件） public class PartA { public int a=1;}public class PartB { public int b=1;}public class PartC { public int c=1;} 产品角色 public class Car { PartA partA; PartB partB; PartC partC; public void setPartA(PartA partA) { this.partA = partA; } public void setPartB(PartB partB) { this.partB = partB; } public void setPartC(PartC partC) { this.partC = partC; } public void show(){ System.out.println(partA.a); }} 抽象建造者 abstract class Builder { protected Car car = new Car(); abstract void setPartA(); abstract void setPartB(); abstract void setPartC(); public Car getCar() { return car; }} 具体建造者 public class ConcreteBuilder extends Builder { @Override void setPartA() { car.setPartA(new PartA()); } @Override void setPartB() { car.setPartB(new PartB()); } @Override void setPartC() { car.setPartC(new PartC()); }} 指挥者 public class Director { private Builder builder; public Director(Builder builder) { this.builder = builder; } public Car getCar(){ builder.setPartA(); builder.setPartB(); builder.setPartC(); return builder.getCar(); }} 消费者 public class Custom { public static void main(String[] args) { Director director=new Director(new ConcreteBuilder()); Car car = director.getCar(); car.show(); }}","link":"/design-pattern/builder/"}],"tags":[{"name":"java","slug":"java","link":"/tags/java/"},{"name":"大数据","slug":"大数据","link":"/tags/%E5%A4%A7%E6%95%B0%E6%8D%AE/"},{"name":"docker","slug":"docker","link":"/tags/docker/"},{"name":"设计模式","slug":"设计模式","link":"/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"}],"categories":[]}