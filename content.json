{"pages":[{"title":"关于我","text":"个人简介 90后的程序员一枚，想要把所有让我一开始觉得困惑的技术弄懂，崇拜大牛，喜欢打游戏，写博客，钻研技术。 个人寄语 no code，no bb","link":"/about/index.html"}],"posts":[{"title":"maven快速生成项目的脚手架","text":"在我们实际开发过程中，好多项目的模板都是固定的，都要引用相同的包，一遍一遍的复制pom文件是一个办法，但是这种方法很浪费时间和精力，现在mvn为我们提供了一个archetype功能，现在记录一下，方便使用。 创建模板项目利用idea创建一个maven的项目，里面加上一些常用的包 生成archetype 执行 mvn clean 成功之后执行第二步 mvn archetype:create-from-project 此时如果执行成功会在当前目录下生成一个target文件夹 进入archetype目录，执行以下命令 mvn install 将项目打包成jar包，并安装在本地仓库 执行如下命令 mvn archetype:crawl 看一下官网的解释 扫描仓库，并在仓库的目录下创建一个archetype-catalog.xml 的文件 打开这个文件就能看见你的这个项目的groupId artifactId 等信息 从模板创建项目 新建maven项目，add Archetype groupId ArtifactId version 等信息均由如下产生 Repository 填写 local 点击ok生成archetype 选中create from archeType ，找到你刚添加的项目，点击next，接下来就和创建普通的maven项目是一样的 点击ok，结束之后等待pom中包的引入，然后就会看到和之前一样的项目了","link":"/maven-archetype/"},{"title":"java递归生成菜单","text":"记录java递归生成菜单 List&lt;Menu&gt;menuList=dao.selectMenu();List&lt;Menu&gt;newMenu=buildMenuTree(menuList,0);private List&lt;Menu&gt; buildMenuTree(List&lt;Menu&gt; menuList, Integer pid) { List&lt;Menu&gt; treeList = new ArrayList&lt;&gt;(); menuList.forEach(menu -&gt; { if (menu.getParentId().equals(pid)) { menu.setChildrens(buildMenuTree(menuList, menu.getId())); treeList.add(menu); } }); return treeList; }","link":"/java-utils-menu/"},{"title":"java计算两个时间之间相差月份","text":"记录一下java计算两个时间相差的月份 public static Integer getDifMonth(Date startDate, Date endDate){ Calendar start = Calendar.getInstance(); Calendar end = Calendar.getInstance(); start.setTime(startDate); end.setTime(endDate); int result = end.get(Calendar.MONTH) - start.get(Calendar.MONTH); int month = (end.get(Calendar.YEAR) - start.get(Calendar.YEAR)) * 12; return Math.abs(month + result); }","link":"/java-utils-difftime/"},{"title":"jvm常用的参数含义以及调优","text":"记录java开发过程中常用的jvm参数设置，用以学习和工作中。 jvm性能调优Xmn Xms Xmx Xss有什么区别Xmn、Xms、Xmx、Xss都是JVM对内存的配置参数，我们可以根据不同需要区修改这些参数，以达到运行程序的最好效果。 -Xms 堆内存的最小大小，默认为物理内存的1/64 -Xmx 堆内存的最大大小，默认为物理内存的1/4 -Xmn 堆内新生代的大小。通过这个值也可以得到老生代的大小：-Xmx减去-Xmn -Xss 设置每个线程可使用的内存大小，即栈的大小。在相同物理内存下，减小这个值能生成更多的线程，当然操作系统对一个进程内的线程数还是有限制的，不能无限生成。线程栈的大小是个双刃剑，如果设置过小，可能会出现栈溢出，特别是在该线程内有递归、大的循环时出现溢出的可能性更大，如果该值设置过大，就有影响到创建栈的数量，如果是多线程的应用，就会出现内存溢出的错误。 jvm配置 堆设置 -Xms:初始堆大小 默认为物理内存的1/64 -Xmx:最大堆大小 默认为物理内存的1/4 -Xmn:新生代大小 -XX:NewRatio:设置新生代和老年代的比值。如：为3，表示年轻代与老年代比值为1：3 -XX:SurvivorRatio:新生代中Eden区与两个Survivor区的比值。注意Survivor区有两个。如：为3，表示Eden：Survivor=3：2，一个Survivor区占整个新生代的1/5 -XX:MaxTenuringThreshold:设置转入老年代的存活次数。如果是0，则直接跳过新生代进入老年代 -XX:PermSize、**-XX:MaxPermSize**:分别设置永久代最小大小与最大大小（Java8以前） -XX:MetaspaceSize、**-XX:MaxMetaspaceSize**:分别设置元空间最小大小与最大大小（Java8以后） 收集器设置 -XX:+UseSerialGC:设置串行收集器 -XX:+UseParallelGC:设置并行收集器 -XX:+UseParalledlOldGC:设置并行老年代收集器 -XX:+UseConcMarkSweepGC:设置并发收集器 垃圾回收统计信息 -XX:+PrintGC -XX:+PrintGCDetails -XX:+PrintGCTimeStamps -Xloggc:filename 并行收集器设置 -XX:ParallelGCThreads=n:设置并行收集器收集时使用的CPU数。并行收集线程数。 -XX:MaxGCPauseMillis=n:设置并行收集最大暂停时间 -XX:GCTimeRatio=n:设置垃圾回收时间占程序运行时间的百分比。公式为1/(1+n) 并发收集器设 置 -XX:+CMSIncrementalMode:设置为增量模式。适用于单CPU情况。 -XX:ParallelGCThreads=n:设置并发收集器新生代收集方式为并行收集时，使用的CPU数。并行收集线程数。 jvm调优工具JPofiler 分析dump内存文件，快速定位问题泄露 获取堆中的数据 获取大的对象","link":"/jvm-good/"},{"title":"java内存区域与内存溢出异常","text":"Java运行时的数据区域Java虚拟机在执行Java程序的过程中会把他所管理的内存划分为不同的数据区域，这些区域各有各的作用，也各有各的声明周期 虚拟机栈、本地方法区、程序计数器一定不会有垃圾。 程序计数器一块较小的内存空间，是当前线程所执行的字节码的行号指示器。在jvm中，字节码解释器通过改变这个程序计数器的值，来控制程序的分支、跳转、异常处理、线程恢复等功能 Java虚拟机栈虚拟机栈描述的是Java方法执行的线程内存模型：每个方法被执行的时候，Java虚拟机都会同步创建一个栈帧，用于存储局部变量表，操作数栈、动态连接，方法出入口等信息。每一个方法被调用直至执行完毕的过程，就对应着一个栈帧在虚拟机栈中从入栈到出栈的过程。 局部变量表： ==存放了编译器可知的各种Java虚拟机基本数据类型（boolean，byte，char，short，int，float，long，double）、对象引用和returnAddress类型。== 方法区被所有的线程共享，所有的字段和方法字节码、以及一些特殊的方法、如构造函数、接口代码也在此定义，简单说，所有定义的方法的信息都在此处，此区域属于共享空间。 ==静态变量、常量、类信息（构造方法、接口定义）、运行时的常量池存在方法区中，但是实际变量存在堆方法中，与方法区无关== static final Class模板、常量池 堆（Heap）一个jvm只有一个JVM，堆内存的大小是可以调节的 堆内存中要分为三个地方 新生区 养老区 永久区 垃圾回收主要是在伊甸园区和养老区 在jdk8以后，永久存储区改了一个名字（元空间）； 新生区 类诞生和成长甚至死亡的地方 伊甸园区，所有的对象都是在伊甸园区new出来的 幸存区（0，1） 真相：经过研究，有90的的类都存活不到养老区 永久区这个区域常驻内存，用来存储JDK自带的Class对象，Interface元数据，存储的java运行时的一些内存和类信息，这个区域不存在垃圾回收，关闭虚拟机会释放这个区域的内存。 jdk1.6之前：永久代，常量池在方法区中 Jdk1.7 :去永久代，常量池在堆中 Jdk1.8 ：元空间，常量池在元空间中 GC GC两种类型：轻GC， 重GC GC算法 标记清除法 标记压缩法 引用计数法 复制算法 类加载器==class 是抽象的，用new 关键字出来的才是具体的类。== 作用加载class文件 分类 虚拟机自带的加载器 启动类（根）加载器 bootstrap class loader c++编写，主要针对于rt.jar 拓展类加载器 extension class loader 主要针对于ext底下的包 应用程序加载器 app 主要针对于用户路径下的包 双亲委派机制（双亲委派模型在jdk1.2的时候被引入）如果一个类加载器收到了类加载的请求，首先他不会自己去尝试加载这个类，而是把这个请求委派给父类加载器去完成，每一个层次的类加载器都是如此，因此所有的加载请求最终都应该传送到最顶层的类加载器中。只有当父类加载器反馈自己无法完成这个类加载请求时，子加载器才会尝试自己去调用类加载。 作用： 1、防止重复加载同一个.class。通过委托去向上面问一问，加载过了，就不用再加载一遍。保证数据安全。 2、保证核心.class不能被篡改。通过委托方式，不会去篡改核心.clas，即使篡改也不会去加载，即使加载也不会是同一个.class对象了。不同的加载器加载同一个.class也不是同一个Class对象。这样保证了Class执行安全。 Native 关键字、方法区凡是带有native关键字的，说明java的作用范围达不到了，会去调用底层c语言的库。 会调用本地方法栈 调用本地方法接口（JNI） JNI作用：拓展java使用，融合不同语言为java所用 历史：java诞生之初 C C++ 横行，想要立足 必须调用C和C++的方法 三种java虚拟机 HotSpot （sun公司） BEA JRockit IBM J9 Vm","link":"/jvm-model/"},{"title":"代理模式","text":"为什么要学习代理模式，因为这是springAop的底层实现。[springAop和springMvc] 静态代理角色分析 抽象角色：一般会使用接口或者抽象类来解决 真实角色：被代理的角色 代理角色：代理真实角色，代理真实角色之后一般我们会做一些附属操作 客户 代码 真实角色 public class Host implements Rent { public void rent() { System.out.println(&quot;房东出租房子&quot;); }} 代理 public class Proxy implements Rent { Host host; public Proxy(Host host) { kanfang(); this.host = host; money(); qianhetong(); } public Proxy() { } public void rent() { this.host.rent(); } public void money() { System.out.println(&quot;收钱&quot;); } public void kanfang() { System.out.println(&quot;看房&quot;); } public void qianhetong() { System.out.println(&quot;签合同&quot;); }} 接口（公共事情） public interface Rent { /** * 出租房子 */ void rent();} 客户 public class Client { public static void main(String[] args) { Host host=new Host(); Proxy proxy = new Proxy(host); proxy.rent(); }} 代理模式的好处 使真实角色更加纯粹 公共也交给了代理角色，实现了业务的分工 公共业务实现了拓展可以集中管理 缺点 一个真实角色就会有产生一个代理角色，代码量会翻倍 动态代理 动态代理和静态代理角色一样 动态代理的动态类是自动生成的，不是我们之前写好的 动态代理分为两大类，基于接口的动态代理，基于类的动态代理 基于接口：JDK动态代理 基于类：clib java字节码实现：javassist 需要了解2个类：Proxy 和 invocationHandler（调用处理程序） 代码 动态代理 public class ProxyInvocationHandler implements InvocationHandler { private Object target; public void setTarget(Object target) { this.target = target; } // Foo f = (Foo) Proxy.newProxyInstance(Foo.class.getClassLoader(),// new Class&lt;?&gt;[] { Foo.class },// handler); public Object getProxy() { return Proxy.newProxyInstance(this.getClass().getClassLoader(), this.target.getClass().getInterfaces(), this); } /** * @param proxy * @param method * @param args * @return * @throws Throwable */ public Object invoke(Object proxy, Method method, Object[] args) throws Throwable { Object invoke = method.invoke(target, args); return invoke; }} 真实角色 public class Host implements Rent { public void rent() { System.out.println(&quot;房东出租房子&quot;); }} 接口 public interface Rent { /** * 出租房子 */ void rent();} 客户 public class Client { public static void main(String[] args) { Host2 host=new Host2(); ProxyInvocationHandler pih = new ProxyInvocationHandler(); pih.setTarget(host); Rent2 rent= (Rent2) pih.getProxy(); System.out.println(rent.rent(&quot;a&quot;)); }}","link":"/design-pattern-proxy/"},{"title":"docker简介及安装","text":"什么是dockerDocker 是一个开源的应用容器引擎，基于 Go 语言并遵从 Apache2.0 协议开源。 Docker 可以让开发者打包他们的应用以及依赖包到一个轻量级、可移植的容器中，然后发布到任何流行的 Linux 机器上，也可以实现虚拟化。 容器是完全使用沙箱机制，相互之间不会有任何接口（类似 iPhone 的 app）,更重要的是容器性能开销极低。 docker与传统的虚拟机有什么区别 vm与docker框架，直观上来讲vm多了一层guest OS，同时Hypervisor会对硬件资源进行虚拟化，docker直接使用硬件资源，所以资源利用率相对docker低也是比较容易理解的 docker的安装与常见问题环境 操作系统：macos 10.15.6 窗口：iTerm2 工具包：homebrew 安装 打开iterm窗口 输入命令 brew cask install docker 等待docker安装完成 docker安装完成之后在启动台中会有docker启动项 打开docker，第一启动会有点慢，甚至可能会出现一直staring的现象，一会说一下解决办法 更换国内镜像 打开preferences-&gt;docker engine {&quot;experimental&quot;:true,&quot;debug&quot;:true,&quot;registry-mirrors&quot;:[ &quot;https://docker.mirrors.ustc.edu.cn&quot; ]} 重启docker docker初始化一直starting的解决办法点击preference，打开右上角小虫子形状的按钮，点击clean/purge data，稍等一会看问题是否可以解决，笔者是通过这种方式解决的问题","link":"/tool-docker-docker-install/"},{"title":"mysql常见的优化","text":"sql的优化主要是围绕着在查询语句的时候尽量使用索引避免全表扫描。 此贴记录一下mysql中常见的优化语句 使用索引 对查询进行优化，应尽量避免全表扫描，首先应考虑在 where 及 order by 涉及的列上建立索引。 避免判断null值 mysql 在使用is null 和is not null 的时候均不使用索引 不要使用%like mysql 在使用%like 的时候不会使用索引 复合索引要符合最左前缀法则(带头大哥不能死，中间兄弟不能断) 小表驱动大表 Exists 或者in 的使用 如果 A小于b 则用 in select * from a where id in (select id from b) 如果 a表的数据集大约b，则用exists select * from a where exists (select 1 from b where a.id=b.id) 不要使用!= 或者&lt;&gt; 尽量避免使用or select id from table where a=1 or b=2;# 修改为select id from table where a=1 union allselect id from table where b=2 常见的sql写法优化 # 大数据分页# 低性能SELECT c1,c2,cn… FROM table LIMIT n,m# 高性能select c1,c2,cn... from table where id in(select id from table limit n,m)# 尽量避免使用selec * # 注意 exist 和 in 使用的时机select num from a where num in(select num from b)#用下面的语句替换：select num from a where exists(select 1 from b where num=a.num)","link":"/mysql-optimize/"},{"title":"mysql知识总结","text":"","link":"/mysql-knowledge/"},{"title":"mysql主从复制","text":"","link":"/mysql-master-slaver-copy/"},{"title":"mysql索引","text":"","link":"/mysql-index/"},{"title":"单例模式","text":"单例模式（Singleton Pattern）是 Java 中最简单的设计模式之一。这种类型的设计模式属于创建型模式，它提供了一种创建对象的最佳方式。这种模式涉及到一个单一的类，该类负责创建自己的对象，同时确保只有单个对象被创建。这个类提供了一种访问其唯一的对象的方式，可以直接访问，不需要实例化该类的对象。 介绍意图：保证一个类仅有一个实例，并提供一个访问它的全局访问点。 主要解决：一个全局使用的类频繁地创建与销毁。 何时使用：当您想控制实例数目，节省系统资源的时候。 如何解决：判断系统是否已经有这个单例，如果有则返回，如果没有则创建。 关键代码：构造函数是私有的。 应用实例： 1、一个班级只有一个班主任。2、Windows 是多进程多线程的，在操作一个文件的时候，就不可避免地出现多个进程或线程同时操作一个文件的现象，所以所有文件的处理必须通过唯一的实例来进行。3、一些设备管理器常常设计为单例模式，比如一个电脑有两台打印机，在输出的时候就要处理不能两台打印机打印同一个文件。优点： 1、在内存里只有一个实例，减少了内存的开销，尤其是频繁的创建和销毁实例（比如管理学院首页页面缓存）。2、避免对资源的多重占用（比如写文件操作）。缺点：没有接口，不能继承，与单一职责原则冲突，一个类应该只关心内部逻辑，而不关心外面怎么样来实例化。 使用场景： 1、要求生产唯一序列号。2、WEB 中的计数器，不用每次刷新都在数据库里加一次，用单例先缓存起来。3、创建的一个对象需要消耗的资源过多，比如 I/O 与数据库的连接等。注意事项：getInstance() 方法中需要使用同步锁 synchronized (Singleton.class) 防止多线程同时进入造成 instance 被多次实例化。 几种单例模式的创建方式懒汉模式（线程不安全）public class Singleton { private static Singleton instance; private Singleton (){} public static Singleton getInstance() { if (instance == null) { instance = new Singleton(); } return instance; } } 懒汉模式（线程安全）public class Singleton { private static Singleton instance; private Singleton (){} public static synchronized Singleton getInstance() { if (instance == null) { instance = new Singleton(); } return instance; } } 饿汉模式线程是否安全：是优点：没有加锁，执行效率高缺点：类加载时就初始化，浪费内存 public class Singleton { private static Singleton instance = new Singleton(); private Singleton (){} public static Singleton getInstance() { return instance; } } 双检锁/双重校验锁public class Singleton { private volatile static Singleton singleton; private Singleton (){} public static Singleton getSingleton() { if (singleton == null) { synchronized (Singleton.class) { if (singleton == null) { singleton = new Singleton(); } } } return singleton; } } 登记式/静态内部类public class Singleton { private static class SingletonHolder { private static final Singleton INSTANCE = new Singleton(); } private Singleton (){} public static final Singleton getInstance() { return SingletonHolder.INSTANCE; } } 参考 菜鸟教程-单例模式","link":"/design-pattern-singleton/"},{"title":"建造者模式","text":"在软件开发过程中有时需要创建一个复杂的对象，这个复杂对象通常由多个子部件按一定的步骤组合而成。例如，计算机是由 CPU、主板、内存、硬盘、显卡、机箱、显示器、键盘、鼠标等部件组装而成的，采购员不可能自己去组装计算机，而是将计算机的配置要求告诉计算机销售公司，计算机销售公司安排技术人员去组装计算机，然后再交给要买计算机的采购员。 生活中这样的例子很多，如游戏中的不同角色，其性别、个性、能力、脸型、体型、服装、发型等特性都有所差异；还有汽车中的方向盘、发动机、车架、轮胎等部件也多种多样；每封电子邮件的发件人、收件人、主题、内容、附件等内容也各不相同。 以上所有这些产品都是由多个部件构成的，各个部件可以灵活选择，但其创建步骤都大同小异。这类产品的创建无法用前面介绍的工厂模式描述，只有建造者模式可以很好地描述该类产品的创建。 模型的定义及特点建造者（Builder）模式的定义：指将一个复杂对象的构造与它的表示分离，使同样的构建过程可以创建不同的表示，这样的设计模式被称为建造者模式。它是将一个复杂的对象分解为多个简单的对象，然后一步一步构建而成。它将变与不变相分离，即产品的组成部分是不变的，但每一部分是可以灵活选择的。 该模式的主要优点如下： 封装性好，构建和表示分离。 扩展性好，各个具体的建造者相互独立，有利于系统的解耦。 客户端不必知道产品内部组成的细节，建造者可以对创建过程逐步细化，而不对其它模块产生任何影响，便于控制细节风险。其缺点如下： 产品的组成部分必须相同，这限制了其使用范围。 如果产品的内部变化复杂，如果产品内部发生变化，则建造者也要同步修改，后期维护成本较大。 建造者（Builder）模式和工厂模式的关注点不同：建造者模式注重零部件的组装过程，而工厂方法模式更注重零部件的创建过程，但两者可以结合使用。 角色 产品角色（Product）：它是包含多个组成部件的复杂对象，由具体建造者来创建其各个零部件。 抽象建造者（Builder）：它是一个包含创建产品各个子部件的抽象方法的接口，通常还包含一个返回复杂产品的方法 getResult()。 具体建造者(Concrete Builder）：实现 Builder 接口，完成复杂产品的各个部件的具体创建方法。 指挥者（Director）：它调用建造者对象中的部件构造与装配方法完成复杂对象的创建，在指挥者中不涉及具体产品的信息。 代码组成部分（子部件） public class PartA { public int a=1;}public class PartB { public int b=1;}public class PartC { public int c=1;} 产品角色 public class Car { PartA partA; PartB partB; PartC partC; public void setPartA(PartA partA) { this.partA = partA; } public void setPartB(PartB partB) { this.partB = partB; } public void setPartC(PartC partC) { this.partC = partC; } public void show(){ System.out.println(partA.a); }} 抽象建造者 abstract class Builder { protected Car car = new Car(); abstract void setPartA(); abstract void setPartB(); abstract void setPartC(); public Car getCar() { return car; }} 具体建造者 public class ConcreteBuilder extends Builder { @Override void setPartA() { car.setPartA(new PartA()); } @Override void setPartB() { car.setPartB(new PartB()); } @Override void setPartC() { car.setPartC(new PartC()); }} 指挥者 public class Director { private Builder builder; public Director(Builder builder) { this.builder = builder; } public Car getCar(){ builder.setPartA(); builder.setPartB(); builder.setPartC(); return builder.getCar(); }} 消费者 public class Custom { public static void main(String[] args) { Director director=new Director(new ConcreteBuilder()); Car car = director.getCar(); car.show(); }}","link":"/design-pattern-builder/"},{"title":"原型模式","text":"在有些系统中，存在大量相同或相似对象的创建问题，如果用传统的构造函数来创建对象，会比较复杂且耗时耗资源，用原型模式生成对象就很高效，就像孙悟空拔下猴毛轻轻一吹就变出很多孙悟空一样简单。 原型模式的定义与特点原型（Prototype）模式的定义如下：用一个已经创建的实例作为原型，通过复制该原型对象来创建一个和原型相同或相似的新对象。在这里，原型实例指定了要创建的对象的种类。用这种方式创建对象非常高效，根本无须知道对象创建的细节。例如，Windows 操作系统的安装通常较耗时，如果复制就快了很多。在生活中复制的例子非常多，这里不一一列举了。 原型模式的优点： Java 自带的原型模式基于内存二进制流的复制，在性能上比直接 new 一个对象更加优良。 可以使用深克隆方式保存对象的状态，使用原型模式将对象复制一份，并将其状态保存起来，简化了创建对象的过程，以便在需要的时候使用（例如恢复到历史某一状态），可辅助实现撤销操作。 原型模式的缺点： 需要为每一个类都配置一个 clone 方法 clone 方法位于类的内部，当对已有类进行改造的时候，需要修改代码，违背了开闭原则。 当实现深克隆时，需要编写较为复杂的代码，而且当对象之间存在多重嵌套引用时，为了实现深克隆，每一层对象对应的类都必须支持深克隆，实现起来会比较麻烦。因此，深克隆、浅克隆需要运用得当。 原型模式的结构与实现由于 Java 提供了对象的 clone() 方法，所以用 Java 实现原型模式很简单。 1. 模式的结构原型模式包含以下主要角色。 抽象原型类：规定了具体原型对象必须实现的接口。 具体原型类：实现抽象原型类的 clone() 方法，它是可被复制的对象。 访问类：使用具体原型类中的 clone() 方法来复制新的对象。 代码public class Realizetype implements Cloneable{ Realizetype() { System.out.println(&quot;具体原型创建成功！&quot;); } @Override public Realizetype clone() throws CloneNotSupportedException { return (Realizetype)super.clone(); }} public class PrototypeTest { public static void main(String[] args) throws CloneNotSupportedException { Realizetype obj1 = new Realizetype(); Realizetype obj2 = (Realizetype) obj1.clone(); System.out.println(&quot;obj1==obj2?&quot; + (obj1 == obj2)); }}","link":"/design-pattern-prototype/"},{"title":"hive简介及安装","text":"hive是基于Hadoop的一个数据仓库工具，用来进行数据提取、转化、加载，这是一种可以存储、查询和分析存储在Hadoop中的大规模数据的机制。hive数据仓库工具能将结构化的数据文件映射为一张数据库表，并提供SQL查询功能，能将SQL语句转变成MapReduce任务来执行。Hive的优点是学习成本低，可以通过类似SQL语句实现快速MapReduce统计，使MapReduce变得更加简单，而不必开发专门的MapReduce应用程序。hive十分适合对数据仓库进行统计分析。 hive 的特点 它存储架构在一个数据库中并处理数据到HDFS。 它是专为OLAP设计。 它提供SQL类型语言查询叫HiveQL或HQL。 它是熟知，快速，可扩展和可扩展的 hive的架构 单元名称 操作 用户接口/界面 User InterFaces Hive是一个数据仓库基础工具软件，可以创建用户和HDFS之间互动。用户界面，Hive支持是Hive的Web UI，Hive命令行，HiveHD洞察（在Windows服务器）。 Meta Store 元存储 Hive选择各自的数据库服务器，用以储存表，数据库，列模式或元数据表，它们的数据类型和HDFS映射。 HiveQL处理引擎 HiveQL类似于SQL的查询上Metastore模式信息。这是传统的方式进行MapReduce程序的替代品之一。相反，使用Java编写的MapReduce程序，可以编写为MapReduce工作，并处理它的查询。 执行引擎 HiveQL处理引擎和MapReduce的结合部分是由Hive执行引擎。执行引擎处理查询并产生结果和MapReduce的结果一样。它采用MapReduce方法 HDFS或者HBASE 数据存储 Hadoop的分布式文件系统或者HBASE数据存储技术是用于将数据存储到文件系统。 hive的安装（mac版本） 环境 操作系统：macOS Big Sur版本：11.2.3","link":"/bigdata-hive1/"},{"title":"工厂模式","text":"介绍一下简单工厂、工厂方法、抽象工厂模式 一、简单工厂模式 定义 定义一个工厂类，他可以根据不同的参数，创建不同的实例。众多实例之间有着共同的父类或者接口。实现此功能的方法一般为静态方法 优点 需要什么，仅仅需要传入一个或者多个参数，就能获取到实例，而无需知道其内部的实现过程 ==在简单工厂模式中，用于创建实例的方法通常为静态方法（static），因此简单工厂模式又被成为 静态工厂方法== 代码 package simple;/** * @author mrhy * @date 2021/1/2 09:37 * Copyright (C), 2018-2021 */public class BaoShiJie implements Car { @Override public String name() { return &quot;我是保时捷&quot;; }} package simple;/** * 兰博基尼 * * @author mrhy * @date 2021/1/2 09:38 * Copyright (C), 2018-2021 */public class LanBoJiNi implements Car { @Override public String name() { return &quot;我是兰博基尼&quot;; }} package simple;/** * 汽车接口 * * @author mrhy * @date 2021/1/2 09:36 * Copyright (C), 2018-2021 */public interface Car { String name();} package simple;/** * 汽车工厂 * * @author mrhy * @date 2021/1/2 09:39 * Copyright (C), 2018-2021 */public class CarFactory { public static Car createCar(String name) { if (&quot;lanbo&quot;.equals(name)) { return new LanBoJiNi(); } else if (&quot;baoshijie&quot;.equals(name)) { return new BaoShiJie(); } else { throw new RuntimeException(&quot;未找到车&quot;); } } public static void main(String[] args) { Car lanbo = CarFactory.createCar(&quot;lanbo&quot;); System.out.println(lanbo.name()); Car baoshijie = CarFactory.createCar(&quot;baoshijie&quot;); System.out.println(baoshijie.name()); }} 二、工厂方法模式 定义 工厂方法模式（FACTORY METHOD）是一种常用的类创建型设计模式,此模式的核心精神是封装类中变化的部分，提取其中个性化善变的部分为独立类，通过依赖注入以达到解耦、复用和方便后期维护拓展的目的。它的核心结构有四个角色，分别是抽象工厂；具体工厂；抽象产品；具体产品 优点 封装内部的实现过程，便于拓展 uml图 代码 package factorymethod;/** * 汽车接口 * * @author mrhy * @date 2021/1/2 09:36 * Copyright (C), 2018-2021 */public interface Car { String name();} package factorymethod;/** * 工厂方法的抽象类 * * @author mrhy * @date 2021/1/3 10:15 * Copyright (C), 2018-2021 */public interface Factory { Car newCar();} package factorymethod;/** * @author mrhy * @date 2021/1/2 09:37 * Copyright (C), 2018-2021 */public class BaoShiJie implements Car { @Override public String name() { return &quot;我是保时捷&quot;; }} package factorymethod;import simple.CarFactory;/** * 汽车工厂 * * @author mrhy * @date 2021/1/2 09:39 * Copyright (C), 2018-2021 */public class BaoshijieCarFactory implements Factory { @Override public Car newCar() { return new BaoShiJie(); }} package factorymethod;/** * @author mrhy * @date 2021/1/3 10:21 * Copyright (C), 2018-2021 */public class LanboCarFactory implements Factory { @Override public Car newCar() { return new LanBoJiNi(); } public static void main(String[] args) { Car baoshijie = new BaoshijieCarFactory().newCar(); System.out.println(baoshijie.name()); LanboCarFactory lanboCarFactory = new LanboCarFactory(); System.out.println(lanboCarFactory.newCar().name()); }} package factorymethod;/** * 兰博基尼 * * @author mrhy * @date 2021/1/2 09:38 * Copyright (C), 2018-2021 */public class LanBoJiNi implements Car { @Override public String name() { return &quot;我是兰博基尼&quot;; }} 三、抽象工厂模式 定义 工厂的工厂，主要面对的对象为产品族 uml 代码 package abstractfactory;/** * @author mrhy * @date 2021/1/4 13:54 * Copyright (C), 2018-2021 */public class Customer { public static void main(String[] args) { MiFactory miFactory = new MiFactory(); Phone phone = miFactory.getPhone(); phone.open(); phone.close(); phone.sendMsg(); phone.call(); Router router = miFactory.getRouter(); router.open(); router.close(); router.sendSgn(); HuaweiFactory huaweiFactory = new HuaweiFactory(); Phone phone2 = huaweiFactory.getPhone(); phone2.open(); phone2.close(); phone2.sendMsg(); phone2.call(); Router router2 = huaweiFactory.getRouter(); router2.open(); router2.close(); router2.sendSgn(); }} package abstractfactory;/** * @author mrhy * @date 2021/1/4 13:53 * Copyright (C), 2018-2021 */public class HuaweiFactory implements IFactory { @Override public Phone getPhone() { return new HuaweiIPhone(); } @Override public Router getRouter() { return new HuaWeiRouter(); }} package abstractfactory;/** * 小米手机 * * @author mrhy * @date 2021/1/4 09:50 * Copyright (C), 2018-2021 */public class HuaweiIPhone implements Phone{ @Override public void open() { System.out.println(&quot;华为手机开机&quot;); } @Override public void close() { System.out.println(&quot;华为手机关机&quot;); } @Override public void sendMsg() { System.out.println(&quot;华为手机发短信&quot;); } @Override public void call() { System.out.println(&quot;华为手机打电话&quot;); }} package abstractfactory;/** * @author mrhy * @date 2021/1/4 11:19 * Copyright (C), 2018-2021 */public class HuaWeiRouter implements Router { @Override public void open() { System.out.println(&quot;华为路由器开机&quot;); } @Override public void close() { System.out.println(&quot;华为路由器关闭&quot;); } @Override public void sendSgn() { System.out.println(&quot;华为路由器广播&quot;); }} package abstractfactory;/** * 工厂的基类接口 * * @author mrhy * @date 2021/1/4 13:50 * Copyright (C), 2018-2021 */public interface IFactory { Phone getPhone(); Router getRouter();} package abstractfactory;/** * 小米工厂 * * @author mrhy * @date 2021/1/4 13:52 * Copyright (C), 2018-2021 */public class MiFactory implements IFactory { @Override public Phone getPhone() { return new XiaomiIPhone(); } @Override public Router getRouter() { return new XiaomiRouter(); }} package abstractfactory;/** * 手机接口 * * @author mrhy * @date 2021/1/4 09:44 * Copyright (C), 2018-2021 */public interface Phone { void open(); void close(); void sendMsg(); void call();} package abstractfactory;/** * 路由器 * * @author mrhy * @date 2021/1/4 09:49 * Copyright (C), 2018-2021 */public interface Router { void open(); void close(); void sendSgn();} package abstractfactory;/** * 小米手机 * * @author mrhy * @date 2021/1/4 09:50 * Copyright (C), 2018-2021 */public class XiaomiIPhone implements Phone{ @Override public void open() { System.out.println(&quot;小米手机开机&quot;); } @Override public void close() { System.out.println(&quot;小米手机关机&quot;); } @Override public void sendMsg() { System.out.println(&quot;小米手机发短信&quot;); } @Override public void call() { System.out.println(&quot;小米手机打电话&quot;); }} package abstractfactory;/** * @author mrhy * @date 2021/1/4 11:19 * Copyright (C), 2018-2021 */public class XiaomiRouter implements Router { @Override public void open() { System.out.println(&quot;小米路由器开机&quot;); } @Override public void close() { System.out.println(&quot;小米路由器关闭&quot;); } @Override public void sendSgn() { System.out.println(&quot;小米路由器广播&quot;); }} package abstractfactory;/** * @author mrhy * @date 2021/1/4 13:54 * Copyright (C), 2018-2021 */public class Customer { public static void main(String[] args) { MiFactory miFactory = new MiFactory(); Phone phone = miFactory.getPhone(); phone.open(); phone.close(); phone.sendMsg(); phone.call(); Router router = miFactory.getRouter(); router.open(); router.close(); router.sendSgn(); HuaweiFactory huaweiFactory = new HuaweiFactory(); Phone phone2 = huaweiFactory.getPhone(); phone2.open(); phone2.close(); phone2.sendMsg(); phone2.call(); Router router2 = huaweiFactory.getRouter(); router2.open(); router2.close(); router2.sendSgn(); }}","link":"/design-pattern-factory/"},{"title":"flink的简介及安装","text":"","link":"/flink/"},{"title":"clickhouse的简介及安装","text":"","link":"/clickhouse/"},{"title":"二维数组中的查找","text":"在一个 n * m 的二维数组中，每一行都按照从左到右递增的顺序排序，每一列都按照从上到下递增的顺序排序。请完成一个高效的函数，输入这样的一个二维数组和一个整数，判断数组中是否含有该整数。 示例: 现有矩阵 matrix 如下： [ [1, 4, 7, 11, 15], [2, 5, 8, 12, 19], [3, 6, 9, 16, 22], [10, 13, 14, 17, 24], [18, 21, 23, 26, 30]]给定 target = 5，返回 true。 给定 target = 20，返回 false。 限制： 0 &lt;= n &lt;= 1000 0 &lt;= m &lt;= 1000 来源：力扣（LeetCode）链接：https://leetcode-cn.com/problems/er-wei-shu-zu-zhong-de-cha-zhao-lcof著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。 思路如下：从矩阵的右上角开始遍历，如果比target小，则col++，如果比target大，则row–，找到target则返回true，找不到则返回false； class Solution { public boolean findNumberIn2DArray(int[][] matrix, int target) { if(matrix == null || matrix.length == 0) { return false; } // m 代表行数，n代表列数 int m = matrix.length, n = matrix[0].length; int row = 0, col = n - 1; while(row &lt; m &amp;&amp; col &gt;= 0) { if(matrix[row][col] &gt; target) { col--; }else if(matrix[row][col] &lt; target) { row++; }else { return true; } } return false; }}","link":"/problem-leetcode-jianzhi04/"},{"title":"替换空格","text":"请实现一个函数，把字符串 s 中的每个空格替换成”%20”。 示例 1： 输入：s = “We are happy.”输出：”We%20are%20happy.” 限制： 0 &lt;= s 的长度 &lt;= 10000 来源：力扣（LeetCode）链接：https://leetcode-cn.com/problems/ti-huan-kong-ge-lcof著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。 解题思路：String转换成char数组，遍历 class Solution { public String replaceSpace(String s) { char[]schar=s.toCharArray(); StringBuilder sb=new StringBuilder(); for(char temp:schar){ if(' '==temp){ sb.append(&quot;%20&quot;); }else{ sb.append(temp); } } return sb.toString(); }}","link":"/problem-leetcode-jianzhi05/"},{"title":"用两个栈实现队列","text":"用两个栈实现一个队列。队列的声明如下，请实现它的两个函数 appendTail 和 deleteHead ，分别完成在队列尾部插入整数和在队列头部删除整数的功能。(若队列中没有元素，deleteHead 操作返回 -1 ) 示例 1： 输入：[“CQueue”,”appendTail”,”deleteHead”,”deleteHead”][[],[3],[],[]]输出：[null,null,3,-1]示例 2： 输入：[“CQueue”,”deleteHead”,”appendTail”,”appendTail”,”deleteHead”,”deleteHead”][[],[],[5],[2],[],[]]输出：[null,-1,null,null,5,2]提示： 1 &lt;= values &lt;= 10000最多会对 appendTail、deleteHead 进行 10000 次调用 来源：力扣（LeetCode）链接：https://leetcode-cn.com/problems/yong-liang-ge-zhan-shi-xian-dui-lie-lcof著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。 思路：两个栈实现队列，一个栈（first）负责入，一个栈（second）负责出，当出栈（second）为空时，把入栈（first）的元素放入出栈（second），再进行出栈。 class CQueue { Stack&lt;Integer&gt;firstStack; Stack&lt;Integer&gt;secondStack; public CQueue() { firstStack=new Stack&lt;&gt;(); secondStack=new Stack&lt;&gt;(); } public void appendTail(int value) { firstStack.push(value); } public int deleteHead() { // 如果出栈为空，则看栈1的情况 if(secondStack.isEmpty()){ // 如果栈1也为空，则说明两个栈都没有元素，说明队列为空，返回-1； if(firstStack.isEmpty()){ return -1; }else{ // 遍历栈1，将栈1的元素放入栈2; while(!firstStack.isEmpty()){ secondStack.push( firstStack.pop()); } return secondStack.pop(); } }else{ return secondStack.pop(); } }}/** * Your CQueue object will be instantiated and called as such: * CQueue obj = new CQueue(); * obj.appendTail(value); * int param_2 = obj.deleteHead(); */","link":"/problem-leetcode-jianzhi06/"},{"title":"从尾到头打印单链表","text":"输入一个链表的头节点，从尾到头反过来返回每个节点的值（用数组返回）。 示例 1： 输入：head = [1,3,2]输出：[2,3,1] 解题思路：栈是先入后出的，用栈暂存单链表节点的值 /** * Definition for singly-linked list. * public class ListNode { * int val; * ListNode next; * ListNode(int x) { val = x; } * } */class Solution { public int[] reversePrint(ListNode head) { if(head==null){ return new int[]{}; } Stack&lt;Integer&gt;stack=new Stack&lt;&gt;(); ListNode node=head; int length=0; while(node !=null){ stack.push(node.val); node=node.next; length++; } int[]a=new int[length]; for(int i=0;i&lt;length;i++){ a[i]=stack.pop(); } return a; }} 另：用栈的地方就可以用递归，可以思考一下递归的写法。","link":"/problem-leetcode-jianzhi06/"},{"title":"青蛙跳台阶问题","text":"一只青蛙一次可以跳上1级台阶，也可以跳上2级台阶。求该青蛙跳上一个 n 级的台阶总共有多少种跳法。 答案需要取模 1e9+7（1000000007），如计算初始结果为：1000000008，请返回 1。 示例 1： 输入：n = 2输出：2示例 2： 输入：n = 7输出：21示例 3： 输入：n = 0输出：1提示： 0 &lt;= n &lt;= 100 来源：力扣（LeetCode）链接：https://leetcode-cn.com/problems/qing-wa-tiao-tai-jie-wen-ti-lcof著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。 思路：这是典型的斐波那契数列，分析一下，青蛙跳上n级台阶的跳法，比如跳3级的时候有3种，调4级的时候，F（3）+F（2），这个结论思想是：青蛙可以留下1级台阶，也可以留下2级台阶，所以F(n)=F(n-1)+F(n-2) class Solution { public int numWays(int n) { if(n==0){ return 1; } if(n==1){ return 1; } List&lt;Integer&gt;list=new ArrayList&lt;&gt;(); list.add(1); list.add(1); for(int i=2;i&lt;=n;i++){ // 答案需要取模 1e9+7（1000000007），如计算初始结果为：1000000008，请返回 1。 list.add((list.get(i-1)+list.get(i-2))%1000000007); } return list.get(n); }}","link":"/problem-leetcode-jianzhi10-ii/"},{"title":"斐波那契数列","text":"写一个函数，输入 n ，求斐波那契（Fibonacci）数列的第 n 项（即 F(N)）。斐波那契数列的定义如下： F(0) = 0, F(1) = 1F(N) = F(N - 1) + F(N - 2), 其中 N &gt; 1.斐波那契数列由 0 和 1 开始，之后的斐波那契数就是由之前的两数相加而得出。 答案需要取模 1e9+7（1000000007），如计算初始结果为：1000000008，请返回 1。 来源：力扣（LeetCode）链接：https://leetcode-cn.com/problems/fei-bo-na-qi-shu-lie-lcof著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。 思路：如果单纯的斐波那契递归来实现的话，leetcode会提示超时，如下代码 class Solution { public int fib(int n) { if(n==0){ return 0; } if(n==1){ return 1; } return fib(n-1)+fib(n-2); }} 所以用一个list 数组去存储 class Solution { public int fib(int n) { if(n==0){ return 0; } if(n==1){ return 1; } List&lt;Integer&gt;list=new ArrayList&lt;&gt;(); list.add(0); list.add(1); for(int i=2;i&lt;=n;i++){ // 答案需要取模 1e9+7（1000000007），如计算初始结果为：1000000008，请返回 1。 list.add((list.get(i-1)+list.get(i-2))%1000000007); } return list.get(n); }}","link":"/problem-leetcode-jianzhi10-i/"},{"title":"旋转数组的最小数字","text":"把一个数组最开始的若干个元素搬到数组的末尾，我们称之为数组的旋转。输入一个递增排序的数组的一个旋转，输出旋转数组的最小元素。例如，数组 [3,4,5,1,2] 为 [1,2,3,4,5] 的一个旋转，该数组的最小值为1。 示例 1： 输入：[3,4,5,1,2]输出：1示例 2： 输入：[2,2,2,0,1]输出：0 来源：力扣（LeetCode）链接：https://leetcode-cn.com/problems/xuan-zhuan-shu-zu-de-zui-xiao-shu-zi-lcof著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。 思路：遍历数组，找到数组中当前元素比上一个元素小的最开始的位置，如果没有找到，则数组为升序，返回第一个元素。 class Solution { public int minArray(int[] numbers) { if(numbers.length==1){ return numbers[0]; } for(int i=1;i&lt;numbers.length;i++){ if(numbers[i]&lt;numbers[i-1]){ return numbers[i]; } } return numbers[0]; }}","link":"/problem-leetcode-jianzhi11/"},{"title":"ReentrantLock","text":"先贴一下源码 public class ReentrantLock implements Lock, java.io.Serializable { private static final long serialVersionUID = 7373984872572414699L; /** Synchronizer providing all implementation mechanics */ private final Sync sync; /** * Base of synchronization control for this lock. Subclassed * into fair and nonfair versions below. Uses AQS state to * represent the number of holds on the lock. */ abstract static class Sync extends AbstractQueuedSynchronizer { private static final long serialVersionUID = -5179523762034025860L; /** * Performs {@link Lock#lock}. The main reason for subclassing * is to allow fast path for nonfair version. */ abstract void lock(); /** * Performs non-fair tryLock. tryAcquire is implemented in * subclasses, but both need nonfair try for trylock method. */ final boolean nonfairTryAcquire(int acquires) { final Thread current = Thread.currentThread(); int c = getState(); if (c == 0) { if (compareAndSetState(0, acquires)) { setExclusiveOwnerThread(current); return true; } } else if (current == getExclusiveOwnerThread()) { int nextc = c + acquires; if (nextc &lt; 0) // overflow throw new Error(&quot;Maximum lock count exceeded&quot;); setState(nextc); return true; } return false; } protected final boolean tryRelease(int releases) { int c = getState() - releases; if (Thread.currentThread() != getExclusiveOwnerThread()) throw new IllegalMonitorStateException(); boolean free = false; if (c == 0) { free = true; setExclusiveOwnerThread(null); } setState(c); return free; } protected final boolean isHeldExclusively() { // While we must in general read state before owner, // we don't need to do so to check if current thread is owner return getExclusiveOwnerThread() == Thread.currentThread(); } final ConditionObject newCondition() { return new ConditionObject(); } // Methods relayed from outer class final Thread getOwner() { return getState() == 0 ? null : getExclusiveOwnerThread(); } final int getHoldCount() { return isHeldExclusively() ? getState() : 0; } final boolean isLocked() { return getState() != 0; } /** * Reconstitutes the instance from a stream (that is, deserializes it). */ private void readObject(java.io.ObjectInputStream s) throws java.io.IOException, ClassNotFoundException { s.defaultReadObject(); setState(0); // reset to unlocked state } } /** * Sync object for non-fair locks */ static final class NonfairSync extends Sync { private static final long serialVersionUID = 7316153563782823691L; /** * Performs lock. Try immediate barge, backing up to normal * acquire on failure. */ final void lock() { if (compareAndSetState(0, 1)) setExclusiveOwnerThread(Thread.currentThread()); else acquire(1); } protected final boolean tryAcquire(int acquires) { return nonfairTryAcquire(acquires); } } /** * Sync object for fair locks */ static final class FairSync extends Sync { private static final long serialVersionUID = -3000897897090466540L; final void lock() { acquire(1); } /** * Fair version of tryAcquire. Don't grant access unless * recursive call or no waiters or is first. */ protected final boolean tryAcquire(int acquires) { final Thread current = Thread.currentThread(); int c = getState(); if (c == 0) { if (!hasQueuedPredecessors() &amp;&amp; compareAndSetState(0, acquires)) { setExclusiveOwnerThread(current); return true; } } else if (current == getExclusiveOwnerThread()) { int nextc = c + acquires; if (nextc &lt; 0) throw new Error(&quot;Maximum lock count exceeded&quot;); setState(nextc); return true; } return false; } } /** * Creates an instance of {@code ReentrantLock}. * This is equivalent to using {@code ReentrantLock(false)}. */ public ReentrantLock() { sync = new NonfairSync(); } /** * Creates an instance of {@code ReentrantLock} with the * given fairness policy. * * @param fair {@code true} if this lock should use a fair ordering policy */ public ReentrantLock(boolean fair) { sync = fair ? new FairSync() : new NonfairSync(); } /** * Acquires the lock. * * &lt;p&gt;Acquires the lock if it is not held by another thread and returns * immediately, setting the lock hold count to one. * * &lt;p&gt;If the current thread already holds the lock then the hold * count is incremented by one and the method returns immediately. * * &lt;p&gt;If the lock is held by another thread then the * current thread becomes disabled for thread scheduling * purposes and lies dormant until the lock has been acquired, * at which time the lock hold count is set to one. */ public void lock() { sync.lock(); } /** * Acquires the lock unless the current thread is * {@linkplain Thread#interrupt interrupted}. * * &lt;p&gt;Acquires the lock if it is not held by another thread and returns * immediately, setting the lock hold count to one. * * &lt;p&gt;If the current thread already holds this lock then the hold count * is incremented by one and the method returns immediately. * * &lt;p&gt;If the lock is held by another thread then the * current thread becomes disabled for thread scheduling * purposes and lies dormant until one of two things happens: * * &lt;ul&gt; * * &lt;li&gt;The lock is acquired by the current thread; or * * &lt;li&gt;Some other thread {@linkplain Thread#interrupt interrupts} the * current thread. * * &lt;/ul&gt; * * &lt;p&gt;If the lock is acquired by the current thread then the lock hold * count is set to one. * * &lt;p&gt;If the current thread: * * &lt;ul&gt; * * &lt;li&gt;has its interrupted status set on entry to this method; or * * &lt;li&gt;is {@linkplain Thread#interrupt interrupted} while acquiring * the lock, * * &lt;/ul&gt; * * then {@link InterruptedException} is thrown and the current thread's * interrupted status is cleared. * * &lt;p&gt;In this implementation, as this method is an explicit * interruption point, preference is given to responding to the * interrupt over normal or reentrant acquisition of the lock. * * @throws InterruptedException if the current thread is interrupted */ public void lockInterruptibly() throws InterruptedException { sync.acquireInterruptibly(1); } /** * Acquires the lock only if it is not held by another thread at the time * of invocation. * * &lt;p&gt;Acquires the lock if it is not held by another thread and * returns immediately with the value {@code true}, setting the * lock hold count to one. Even when this lock has been set to use a * fair ordering policy, a call to {@code tryLock()} &lt;em&gt;will&lt;/em&gt; * immediately acquire the lock if it is available, whether or not * other threads are currently waiting for the lock. * This &amp;quot;barging&amp;quot; behavior can be useful in certain * circumstances, even though it breaks fairness. If you want to honor * the fairness setting for this lock, then use * {@link #tryLock(long, TimeUnit) tryLock(0, TimeUnit.SECONDS) } * which is almost equivalent (it also detects interruption). * * &lt;p&gt;If the current thread already holds this lock then the hold * count is incremented by one and the method returns {@code true}. * * &lt;p&gt;If the lock is held by another thread then this method will return * immediately with the value {@code false}. * * @return {@code true} if the lock was free and was acquired by the * current thread, or the lock was already held by the current * thread; and {@code false} otherwise */ public boolean tryLock() { return sync.nonfairTryAcquire(1); } /** * Acquires the lock if it is not held by another thread within the given * waiting time and the current thread has not been * {@linkplain Thread#interrupt interrupted}. * * &lt;p&gt;Acquires the lock if it is not held by another thread and returns * immediately with the value {@code true}, setting the lock hold count * to one. If this lock has been set to use a fair ordering policy then * an available lock &lt;em&gt;will not&lt;/em&gt; be acquired if any other threads * are waiting for the lock. This is in contrast to the {@link #tryLock()} * method. If you want a timed {@code tryLock} that does permit barging on * a fair lock then combine the timed and un-timed forms together: * * &lt;pre&gt; {@code * if (lock.tryLock() || * lock.tryLock(timeout, unit)) { * ... * }}&lt;/pre&gt; * * &lt;p&gt;If the current thread * already holds this lock then the hold count is incremented by one and * the method returns {@code true}. * * &lt;p&gt;If the lock is held by another thread then the * current thread becomes disabled for thread scheduling * purposes and lies dormant until one of three things happens: * * &lt;ul&gt; * * &lt;li&gt;The lock is acquired by the current thread; or * * &lt;li&gt;Some other thread {@linkplain Thread#interrupt interrupts} * the current thread; or * * &lt;li&gt;The specified waiting time elapses * * &lt;/ul&gt; * * &lt;p&gt;If the lock is acquired then the value {@code true} is returned and * the lock hold count is set to one. * * &lt;p&gt;If the current thread: * * &lt;ul&gt; * * &lt;li&gt;has its interrupted status set on entry to this method; or * * &lt;li&gt;is {@linkplain Thread#interrupt interrupted} while * acquiring the lock, * * &lt;/ul&gt; * then {@link InterruptedException} is thrown and the current thread's * interrupted status is cleared. * * &lt;p&gt;If the specified waiting time elapses then the value {@code false} * is returned. If the time is less than or equal to zero, the method * will not wait at all. * * &lt;p&gt;In this implementation, as this method is an explicit * interruption point, preference is given to responding to the * interrupt over normal or reentrant acquisition of the lock, and * over reporting the elapse of the waiting time. * * @param timeout the time to wait for the lock * @param unit the time unit of the timeout argument * @return {@code true} if the lock was free and was acquired by the * current thread, or the lock was already held by the current * thread; and {@code false} if the waiting time elapsed before * the lock could be acquired * @throws InterruptedException if the current thread is interrupted * @throws NullPointerException if the time unit is null */ public boolean tryLock(long timeout, TimeUnit unit) throws InterruptedException { return sync.tryAcquireNanos(1, unit.toNanos(timeout)); } /** * Attempts to release this lock. * * &lt;p&gt;If the current thread is the holder of this lock then the hold * count is decremented. If the hold count is now zero then the lock * is released. If the current thread is not the holder of this * lock then {@link IllegalMonitorStateException} is thrown. * * @throws IllegalMonitorStateException if the current thread does not * hold this lock */ public void unlock() { sync.release(1); } /** * Returns a {@link Condition} instance for use with this * {@link Lock} instance. * * &lt;p&gt;The returned {@link Condition} instance supports the same * usages as do the {@link Object} monitor methods ({@link * Object#wait() wait}, {@link Object#notify notify}, and {@link * Object#notifyAll notifyAll}) when used with the built-in * monitor lock. * * &lt;ul&gt; * * &lt;li&gt;If this lock is not held when any of the {@link Condition} * {@linkplain Condition#await() waiting} or {@linkplain * Condition#signal signalling} methods are called, then an {@link * IllegalMonitorStateException} is thrown. * * &lt;li&gt;When the condition {@linkplain Condition#await() waiting} * methods are called the lock is released and, before they * return, the lock is reacquired and the lock hold count restored * to what it was when the method was called. * * &lt;li&gt;If a thread is {@linkplain Thread#interrupt interrupted} * while waiting then the wait will terminate, an {@link * InterruptedException} will be thrown, and the thread's * interrupted status will be cleared. * * &lt;li&gt; Waiting threads are signalled in FIFO order. * * &lt;li&gt;The ordering of lock reacquisition for threads returning * from waiting methods is the same as for threads initially * acquiring the lock, which is in the default case not specified, * but for &lt;em&gt;fair&lt;/em&gt; locks favors those threads that have been * waiting the longest. * * &lt;/ul&gt; * * @return the Condition object */ public Condition newCondition() { return sync.newCondition(); } /** * Queries the number of holds on this lock by the current thread. * * &lt;p&gt;A thread has a hold on a lock for each lock action that is not * matched by an unlock action. * * &lt;p&gt;The hold count information is typically only used for testing and * debugging purposes. For example, if a certain section of code should * not be entered with the lock already held then we can assert that * fact: * * &lt;pre&gt; {@code * class X { * ReentrantLock lock = new ReentrantLock(); * // ... * public void m() { * assert lock.getHoldCount() == 0; * lock.lock(); * try { * // ... method body * } finally { * lock.unlock(); * } * } * }}&lt;/pre&gt; * * @return the number of holds on this lock by the current thread, * or zero if this lock is not held by the current thread */ public int getHoldCount() { return sync.getHoldCount(); } /** * Queries if this lock is held by the current thread. * * &lt;p&gt;Analogous to the {@link Thread#holdsLock(Object)} method for * built-in monitor locks, this method is typically used for * debugging and testing. For example, a method that should only be * called while a lock is held can assert that this is the case: * * &lt;pre&gt; {@code * class X { * ReentrantLock lock = new ReentrantLock(); * // ... * * public void m() { * assert lock.isHeldByCurrentThread(); * // ... method body * } * }}&lt;/pre&gt; * * &lt;p&gt;It can also be used to ensure that a reentrant lock is used * in a non-reentrant manner, for example: * * &lt;pre&gt; {@code * class X { * ReentrantLock lock = new ReentrantLock(); * // ... * * public void m() { * assert !lock.isHeldByCurrentThread(); * lock.lock(); * try { * // ... method body * } finally { * lock.unlock(); * } * } * }}&lt;/pre&gt; * * @return {@code true} if current thread holds this lock and * {@code false} otherwise */ public boolean isHeldByCurrentThread() { return sync.isHeldExclusively(); } /** * Queries if this lock is held by any thread. This method is * designed for use in monitoring of the system state, * not for synchronization control. * * @return {@code true} if any thread holds this lock and * {@code false} otherwise */ public boolean isLocked() { return sync.isLocked(); } /** * Returns {@code true} if this lock has fairness set true. * * @return {@code true} if this lock has fairness set true */ public final boolean isFair() { return sync instanceof FairSync; } /** * Returns the thread that currently owns this lock, or * {@code null} if not owned. When this method is called by a * thread that is not the owner, the return value reflects a * best-effort approximation of current lock status. For example, * the owner may be momentarily {@code null} even if there are * threads trying to acquire the lock but have not yet done so. * This method is designed to facilitate construction of * subclasses that provide more extensive lock monitoring * facilities. * * @return the owner, or {@code null} if not owned */ protected Thread getOwner() { return sync.getOwner(); } /** * Queries whether any threads are waiting to acquire this lock. Note that * because cancellations may occur at any time, a {@code true} * return does not guarantee that any other thread will ever * acquire this lock. This method is designed primarily for use in * monitoring of the system state. * * @return {@code true} if there may be other threads waiting to * acquire the lock */ public final boolean hasQueuedThreads() { return sync.hasQueuedThreads(); } /** * Queries whether the given thread is waiting to acquire this * lock. Note that because cancellations may occur at any time, a * {@code true} return does not guarantee that this thread * will ever acquire this lock. This method is designed primarily for use * in monitoring of the system state. * * @param thread the thread * @return {@code true} if the given thread is queued waiting for this lock * @throws NullPointerException if the thread is null */ public final boolean hasQueuedThread(Thread thread) { return sync.isQueued(thread); } /** * Returns an estimate of the number of threads waiting to * acquire this lock. The value is only an estimate because the number of * threads may change dynamically while this method traverses * internal data structures. This method is designed for use in * monitoring of the system state, not for synchronization * control. * * @return the estimated number of threads waiting for this lock */ public final int getQueueLength() { return sync.getQueueLength(); } /** * Returns a collection containing threads that may be waiting to * acquire this lock. Because the actual set of threads may change * dynamically while constructing this result, the returned * collection is only a best-effort estimate. The elements of the * returned collection are in no particular order. This method is * designed to facilitate construction of subclasses that provide * more extensive monitoring facilities. * * @return the collection of threads */ protected Collection&lt;Thread&gt; getQueuedThreads() { return sync.getQueuedThreads(); } /** * Queries whether any threads are waiting on the given condition * associated with this lock. Note that because timeouts and * interrupts may occur at any time, a {@code true} return does * not guarantee that a future {@code signal} will awaken any * threads. This method is designed primarily for use in * monitoring of the system state. * * @param condition the condition * @return {@code true} if there are any waiting threads * @throws IllegalMonitorStateException if this lock is not held * @throws IllegalArgumentException if the given condition is * not associated with this lock * @throws NullPointerException if the condition is null */ public boolean hasWaiters(Condition condition) { if (condition == null) throw new NullPointerException(); if (!(condition instanceof AbstractQueuedSynchronizer.ConditionObject)) throw new IllegalArgumentException(&quot;not owner&quot;); return sync.hasWaiters((AbstractQueuedSynchronizer.ConditionObject)condition); } /** * Returns an estimate of the number of threads waiting on the * given condition associated with this lock. Note that because * timeouts and interrupts may occur at any time, the estimate * serves only as an upper bound on the actual number of waiters. * This method is designed for use in monitoring of the system * state, not for synchronization control. * * @param condition the condition * @return the estimated number of waiting threads * @throws IllegalMonitorStateException if this lock is not held * @throws IllegalArgumentException if the given condition is * not associated with this lock * @throws NullPointerException if the condition is null */ public int getWaitQueueLength(Condition condition) { if (condition == null) throw new NullPointerException(); if (!(condition instanceof AbstractQueuedSynchronizer.ConditionObject)) throw new IllegalArgumentException(&quot;not owner&quot;); return sync.getWaitQueueLength((AbstractQueuedSynchronizer.ConditionObject)condition); } /** * Returns a collection containing those threads that may be * waiting on the given condition associated with this lock. * Because the actual set of threads may change dynamically while * constructing this result, the returned collection is only a * best-effort estimate. The elements of the returned collection * are in no particular order. This method is designed to * facilitate construction of subclasses that provide more * extensive condition monitoring facilities. * * @param condition the condition * @return the collection of threads * @throws IllegalMonitorStateException if this lock is not held * @throws IllegalArgumentException if the given condition is * not associated with this lock * @throws NullPointerException if the condition is null */ protected Collection&lt;Thread&gt; getWaitingThreads(Condition condition) { if (condition == null) throw new NullPointerException(); if (!(condition instanceof AbstractQueuedSynchronizer.ConditionObject)) throw new IllegalArgumentException(&quot;not owner&quot;); return sync.getWaitingThreads((AbstractQueuedSynchronizer.ConditionObject)condition); } /** * Returns a string identifying this lock, as well as its lock state. * The state, in brackets, includes either the String {@code &quot;Unlocked&quot;} * or the String {@code &quot;Locked by&quot;} followed by the * {@linkplain Thread#getName name} of the owning thread. * * @return a string identifying this lock, as well as its lock state */ public String toString() { Thread o = sync.getOwner(); return super.toString() + ((o == null) ? &quot;[Unlocked]&quot; : &quot;[Locked by thread &quot; + o.getName() + &quot;]&quot;); }} 贴一下结构图，然后逐一分析","link":"/java-sourcecode-reentrantlock/"},{"title":"hashMap","text":"抽时间静下心来读一下hashMap的源码，从大佬前辈们的代码中获取灵感，充实自己。gogogo HashMap 初始化通常我们用hashMap的时候会new一个hashMap的对象，那new的过程中发生了什么呢 // 初始化 HashMap&lt;String, String&gt; stringStringHashMap = new HashMap&lt;&gt;(); 走起，点击进来 /** * Constructs an empty &lt;tt&gt;HashMap&lt;/tt&gt; with the default initial capacity * (16) and the default load factor (0.75). */ public HashMap() { this.loadFactor = DEFAULT_LOAD_FACTOR; // all other fields defaulted } 如上所示，HashMap的无参构造方法就只有一行，默认加载因子为0.75，此处没有指定默认的容量，我们往上翻常量 /** * The default initial capacity - MUST be a power of two. */ static final int DEFAULT_INITIAL_CAPACITY = 1 &lt;&lt; 4; // aka 16 /** * The maximum capacity, used if a higher value is implicitly specified * by either of the constructors with arguments. * MUST be a power of two &lt;= 1&lt;&lt;30. */ static final int MAXIMUM_CAPACITY = 1 &lt;&lt; 30; /** * The load factor used when none specified in constructor. */ static final float DEFAULT_LOAD_FACTOR = 0.75f; /** * The bin count threshold for using a tree rather than list for a * bin. Bins are converted to trees when adding an element to a * bin with at least this many nodes. The value must be greater * than 2 and should be at least 8 to mesh with assumptions in * tree removal about conversion back to plain bins upon * shrinkage. */ static final int TREEIFY_THRESHOLD = 8; /** * The bin count threshold for untreeifying a (split) bin during a * resize operation. Should be less than TREEIFY_THRESHOLD, and at * most 6 to mesh with shrinkage detection under removal. */ static final int UNTREEIFY_THRESHOLD = 6; /** * The smallest table capacity for which bins may be treeified. * (Otherwise the table is resized if too many nodes in a bin.) * Should be at least 4 * TREEIFY_THRESHOLD to avoid conflicts * between resizing and treeification thresholds. */ static final int MIN_TREEIFY_CAPACITY = 64; 可以看到 默认初始容量为16 ，再理解一下其他参数 // 最大容量 static final int MAXIMUM_CAPACITY = 1 &lt;&lt; 30;// 默认加载因子static final float DEFAULT_LOAD_FACTOR = 0.75f;// 链表转为红黑树的临界值static final int TREEIFY_THRESHOLD = 8;// 红黑树再次转为链表的临界值static final int UNTREEIFY_THRESHOLD = 6;// 链表转换为红黑树的最小数组的长度，如果不够这个长度则扩容 static final int MIN_TREEIFY_CAPACITY = 64; 从上面 我们再引出一个面试中常问的问题 HashMap的默认初始化加载因子的作用//默认加载因子是threadhold 的决定因素之一，而threadhold是HashMap的table 进行扩容的临界点，举个简单的例子,如果table 初始容量大小为是16，加载因子为0.75，则当数组长度为16*0.75=12的时候，然后下一个put的时候将进行扩容操作。关键代码如下：662-663 HashMap默认加载因子为什么是0.75加载因子是表示Hsah表中元素的填满的程度。 加载因子越大,填满的元素越多,空间利用率越高，但冲突的机会加大了。 反之,加载因子越小,填满的元素越少,冲突的机会减小,但空间浪费多了。 冲突的机会越大,则查找的成本越高。反之,查找的成本越小。 因此,必须在 “冲突的机会”与”空间利用率”之间寻找一种平衡与折衷。 /* Because TreeNodes are about twice the size of regular nodes, we * use them only when bins contain enough nodes to warrant use * (see TREEIFY_THRESHOLD). And when they become too small (due to * removal or resizing) they are converted back to plain bins. In * usages with well-distributed user hashCodes, tree bins are * rarely used. Ideally, under random hashCodes, the frequency of * nodes in bins follows a Poisson distribution * (http://en.wikipedia.org/wiki/Poisson_distribution) with a * parameter of about 0.5 on average for the default resizing * threshold of 0.75, although with a large variance because of * resizing granularity. Ignoring variance, the expected * occurrences of list size k are (exp(-0.5) * pow(0.5, k) / * factorial(k)). The first values are: * * 0: 0.60653066 * 1: 0.30326533 * 2: 0.07581633 * 3: 0.01263606 * 4: 0.00157952 * 5: 0.00015795 * 6: 0.00001316 * 7: 0.00000094 * 8: 0.00000006 * more: less than 1 in ten million * 简单翻译一下就是在理想情况下,使用随机哈希码,节点出现的频率在hash桶中遵循泊松分布，同时给出了桶中元素个数和概率的对照表。 从上面的表中可以看到当桶中元素到达8个的时候，概率已经变得非常小，也就是说用0.75作为加载因子，每个碰撞位置的链表长度超过８个是几乎不可能的。 HashMap中hash函数的实现过程贴一段String中hash函数实现 public int hashCode() { int h = hash; if (h == 0 &amp;&amp; value.length &gt; 0) { char val[] = value; for (int i = 0; i &lt; value.length; i++) { h = 31 * h + val[i]; } hash = h; } return h; } 将string 转为char数组，取元素在ASCII码中的位置相加，然后依次进行遍历加和（描述不是很准确，看代码吧） 我们在看一下hashMap中的函数，还是以放入的key为String类型为例。代码如下 static final int hash(Object key) { int h; return (key == null) ? 0 : (h = key.hashCode()) ^ (h &gt;&gt;&gt; 16);} 在原有的基础上，对重新对hash进行优化，得出的hashCode 的低16位与高16位进行==异或== 异或 异域的概念是相同为0不同为1.如果两个数值异或后的值相同，异或前可能不同。比如二进制：0010^0001=0011 而0000^0011=0011。 异或的注意点 1.自己与自己异或结果为0， 2.异或满足 交换律。a^b=b^a，即异或满足交换律。 hashMap 中获取hash值异或的好处是什么 保证低16位与高16位只要有一位进行变动，就会对hash值产生影响，减少了hash冲突的可能性。 hashMap中put方法分析当我们输入如下代码，跟着断点看hashMap到底进行了如何操作 HashMap&lt;String, String&gt; stringStringHashMap = new HashMap&lt;&gt;();stringStringHashMap.put(&quot;1&quot;,&quot;1&quot;); 一步一步走 public V put(K key, V value) { return putVal(hash(key), key, value, false, true); }// 此处计算key的hash值，上面已经分析过了，不再过多赘述 看putVal方法 final V putVal(int hash, K key, V value, boolean onlyIfAbsent, boolean evict) { Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; p; int n, i; if ((tab = table) == null || (n = tab.length) == 0) // 第一次放入元素的时候，就会进入此分支，进行resize操作。 n = (tab = resize()).length; if ((p = tab[i = (n - 1) &amp; hash]) == null) // 判断 （当前容器的大小为 -1）与 hashCode相与，判断当前位置是否有元素。 // 引出一个知识点，为什么hashMap的容量一定要设置成2的倍数。 tab[i] = newNode(hash, key, value, null); else { Node&lt;K,V&gt; e; K k; if (p.hash == hash &amp;&amp; ((k = p.key) == key || (key != null &amp;&amp; key.equals(k)))) e = p; else if (p instanceof TreeNode) e = ((TreeNode&lt;K,V&gt;)p).putTreeVal(this, tab, hash, key, value); else { for (int binCount = 0; ; ++binCount) { if ((e = p.next) == null) { p.next = newNode(hash, key, value, null); if (binCount &gt;= TREEIFY_THRESHOLD - 1) // -1 for 1st treeifyBin(tab, hash); break; } if (e.hash == hash &amp;&amp; ((k = e.key) == key || (key != null &amp;&amp; key.equals(k)))) break; p = e; } } if (e != null) { // existing mapping for key V oldValue = e.value; if (!onlyIfAbsent || oldValue == null) e.value = value; afterNodeAccess(e); return oldValue; } } ++modCount; if (++size &gt; threshold) resize(); afterNodeInsertion(evict); return null;} 当我们放入第一个元素时， 因为table为null，所以走第一个if分支，进行resize()操作进行扩容。 final Node&lt;K,V&gt;[] resize() { Node&lt;K,V&gt;[] oldTab = table; // 第一次放入 oldCap为0 int oldCap = (oldTab == null) ? 0 : oldTab.length; // oldThr 也为0； int oldThr = threshold; int newCap, newThr = 0; if (oldCap &gt; 0) { if (oldCap &gt;= MAXIMUM_CAPACITY) { threshold = Integer.MAX_VALUE; return oldTab; } else if ((newCap = oldCap &lt;&lt; 1) &lt; MAXIMUM_CAPACITY &amp;&amp; oldCap &gt;= DEFAULT_INITIAL_CAPACITY) newThr = oldThr &lt;&lt; 1; // double threshold } else if (oldThr &gt; 0) // initial capacity was placed in threshold newCap = oldThr; else { // zero initial threshold signifies using defaults // 第一次放入走else 这个分支，将容量和扩容临界值变为默认值 16 和12 newCap = DEFAULT_INITIAL_CAPACITY; newThr = (int)(DEFAULT_LOAD_FACTOR * DEFAULT_INITIAL_CAPACITY); } if (newThr == 0) { float ft = (float)newCap * loadFactor; newThr = (newCap &lt; MAXIMUM_CAPACITY &amp;&amp; ft &lt; (float)MAXIMUM_CAPACITY ? (int)ft : Integer.MAX_VALUE); } threshold = newThr; @SuppressWarnings({&quot;rawtypes&quot;,&quot;unchecked&quot;}) // 第一次初始化 newCap为16，此处创建一个新的数组结构 Node&lt;K,V&gt;[] newTab = (Node&lt;K,V&gt;[])new Node[newCap]; table = newTab; // 第一次初始化oldTab为null，此时直接返回newTable if (oldTab != null) { for (int j = 0; j &lt; oldCap; ++j) { Node&lt;K,V&gt; e; if ((e = oldTab[j]) != null) { oldTab[j] = null; if (e.next == null) newTab[e.hash &amp; (newCap - 1)] = e; else if (e instanceof TreeNode) ((TreeNode&lt;K,V&gt;)e).split(this, newTab, j, oldCap); else { // preserve order Node&lt;K,V&gt; loHead = null, loTail = null; Node&lt;K,V&gt; hiHead = null, hiTail = null; Node&lt;K,V&gt; next; do { next = e.next; if ((e.hash &amp; oldCap) == 0) { if (loTail == null) loHead = e; else loTail.next = e; loTail = e; } else { if (hiTail == null) hiHead = e; else hiTail.next = e; hiTail = e; } } while ((e = next) != null); if (loTail != null) { loTail.next = null; newTab[j] = loHead; } if (hiTail != null) { hiTail.next = null; newTab[j + oldCap] = hiHead; } } } } } return newTab; } 紧接着我们放入第二个元素,还是看putVal方法 final V putVal(int hash, K key, V value, boolean onlyIfAbsent, boolean evict) { Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; p; int n, i; // 此时不为空，则不走这个if if ((tab = table) == null || (n = tab.length) == 0) n = (tab = resize()).length; // 如果不同，则 tab【i】的位置放入一个新的node节点 if ((p = tab[i = (n - 1) &amp; hash]) == null) tab[i] = newNode(hash, key, value, null); else { // 如果新放入的key与之前某个位置的key产生了冲突 Node&lt;K,V&gt; e; K k; // 判断当前的hash值是否和心如的一样，并且key是否和key一样，如果一样则认为是相同的，将p赋值给e if (p.hash == hash &amp;&amp; ((k = p.key) == key || (key != null &amp;&amp; key.equals(k)))) e = p; else if (p instanceof TreeNode) // 否则，查看这个p节点是否是红黑树的类型 e = ((TreeNode&lt;K,V&gt;)p).putTreeVal(this, tab, hash, key, value); else { // 如果不是红黑树，则插入 for (int binCount = 0; ; ++binCount) { // 此处可以看出，下个节点放在p的后面，也就是尾插法 if ((e = p.next) == null) { p.next = newNode(hash, key, value, null); // 如果当前节点的数量大于等于要树话的临界值 if (binCount &gt;= TREEIFY_THRESHOLD - 1) // -1 for 1st treeifyBin(tab, hash); break; } // 同样去判断是否相等 if (e.hash == hash &amp;&amp; ((k = e.key) == key || (key != null &amp;&amp; key.equals(k)))) break; // 将e 赋值给p p = e; } } if (e != null) { // existing mapping for key V oldValue = e.value; if (!onlyIfAbsent || oldValue == null) e.value = value; afterNodeAccess(e); return oldValue; } } ++modCount; if (++size &gt; threshold) resize(); afterNodeInsertion(evict); return null; } hashMap的容量为什么一定要设置成2的倍数 我们可以看到新元素的位置是由（n-1）&amp;hash码确定的 比如n为15（非2的倍数）减去1 为14 在进行与运算的时候，1110 &amp; hash hash 如果是 1110 和1111 计算出来的结果是一样的，这样就增大了hash冲突的概率，所以不提倡。如果n是2的倍数则可以很好的避免这种情况。 hashMap 链表转换为红黑树的实现final void treeifyBin(Node&lt;K,V&gt;[] tab, int hash) { int n, index; Node&lt;K,V&gt; e; // 如果tab是null 或者tab数组的长度小于最小树化的时候，这时候不是转换成红黑树，而是扩容 if (tab == null || (n = tab.length) &lt; MIN_TREEIFY_CAPACITY) resize(); else if ((e = tab[index = (n - 1) &amp; hash]) != null) { TreeNode&lt;K,V&gt; hd = null, tl = null; do { // replacementTreeNode的代码我也贴一下，实际上就是返回一个trueNode节点 TreeNode&lt;K,V&gt; p = replacementTreeNode(e, null); if (tl == null) hd = p; else { p.prev = tl; tl.next = p; } tl = p; } while ((e = e.next) != null); if ((tab[index] = hd) != null) hd.treeify(tab); } } // For treeifyBin TreeNode&lt;K,V&gt; replacementTreeNode(Node&lt;K,V&gt; p, Node&lt;K,V&gt; next) { return new TreeNode&lt;&gt;(p.hash, p.key, p.value, next); } hashMap 的get方法实现 public V get(Object key) { Node&lt;K,V&gt; e; return (e = getNode(hash(key), key)) == null ? null : e.value; }final Node&lt;K,V&gt; getNode(int hash, Object key) { Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; first, e; int n; K k; // 如果是数组是空，直接返回null，如果不是则进行如下逻辑 if ((tab = table) != null &amp;&amp; (n = tab.length) &gt; 0 &amp;&amp; (first = tab[(n - 1) &amp; hash]) != null) { // 如果是首个节点的hash 和 key都是相等的，则返回首个节点 if (first.hash == hash &amp;&amp; // always check first node ((k = first.key) == key || (key != null &amp;&amp; key.equals(k)))) return first; if ((e = first.next) != null) { // 如果不是，并且节点是treeNode类型，则根据红黑树去找 if (first instanceof TreeNode) return ((TreeNode&lt;K,V&gt;)first).getTreeNode(hash, key); do { // 否则遍历链表 if (e.hash == hash &amp;&amp; ((k = e.key) == key || (key != null &amp;&amp; key.equals(k)))) return e; } while ((e = e.next) != null); } } return null; } hashMap 的remove方法实现public V remove(Object key) { Node&lt;K,V&gt; e; return (e = removeNode(hash(key), key, null, false, true)) == null ? null : e.value; } final Node&lt;K,V&gt; removeNode(int hash, Object key, Object value, boolean matchValue, boolean movable) { Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; p; int n, index; if ((tab = table) != null &amp;&amp; (n = tab.length) &gt; 0 &amp;&amp; (p = tab[index = (n - 1) &amp; hash]) != null) { Node&lt;K,V&gt; node = null, e; K k; V v; //寻找节点 if (p.hash == hash &amp;&amp; ((k = p.key) == key || (key != null &amp;&amp; key.equals(k)))) node = p; else if ((e = p.next) != null) { if (p instanceof TreeNode) node = ((TreeNode&lt;K,V&gt;)p).getTreeNode(hash, key); else { do { if (e.hash == hash &amp;&amp; ((k = e.key) == key || (key != null &amp;&amp; key.equals(k)))) { node = e; break; } p = e; } while ((e = e.next) != null); } } //找到之后断链 if (node != null &amp;&amp; (!matchValue || (v = node.value) == value || (value != null &amp;&amp; value.equals(v)))) { if (node instanceof TreeNode) ((TreeNode&lt;K,V&gt;)node).removeTreeNode(this, tab, movable); else if (node == p) tab[index] = node.next; else p.next = node.next; ++modCount; --size; afterNodeRemoval(node); return node; } } return null; } –未完待续–hashMap树化和非树化的方法","link":"/hashmap/"},{"title":"docker基本命令","text":"本文将介绍一些docker中的命令与目前过程中的一些技巧,这是自己在学习过程中的一些积累，记录下来，方便查询。 docker 命令大全帮助命令docker version --显示docker的版本号docker info --显示docker的详细信息docker &lt;命令行&gt; --help 帮助命令 docker命令行地址：https://docs.docker.com/engine/reference/run/ 镜像命令 docker images 列出镜像 ➜ ~ docker images --helpUsage: docker images [OPTIONS] [REPOSITORY[:TAG]]List imagesOptions: -a, --all Show all images (default hides intermediate images) --digests Show digests -f, --filter filter Filter output based on conditions provided --format string Pretty-print images using a Go template --no-trunc Don't truncate output -q, --quiet Only show image IDs➜ ~ docker imagesREPOSITORY TAG IMAGE ID CREATED SIZEmysql latest ab2f358b8612 4 months ago 545MBzookeeper latest ea93faa92337 4 months ago 253MBredis latest 84c5f6e03bf0 7 months ago 104MBnginx latest 7e4d58f0e5f3 7 months ago 133MB# 解释REPOSITORY：镜像的仓库源TAG：镜像标签IMAGE ID：镜像idCREATED：创建时间SIZE：镜像大小 docker search 搜索镜像 ➜ ~ docker search --helpUsage: docker search [OPTIONS] TERMSearch the Docker Hub for imagesOptions: -f, --filter filter Filter output based on conditions provided --format string Pretty-print search using a Go template --limit int Max number of search results (default 25) --no-trunc Don't truncate output➜ ~ docker search mysqlNAME DESCRIPTION STARS OFFICIAL AUTOMATEDmysql MySQL is a widely used, open-source relation… 10743 [OK]mariadb MariaDB Server is a high performing open sou… 4046 [OK]mysql/mysql-server Optimized MySQL Server Docker images. Create… 790 [OK]percona Percona Server is a fork of the MySQL relati… 532 [OK]centos/mysql-57-centos7 MySQL 5.7 SQL database server 87mysql/mysql-cluster Experimental MySQL Cluster Docker images. Cr… 81centurylink/mysql Image containing mysql. Optimized to be link… 59 [OK]bitnami/mysql Bitnami MySQL Docker Image 50 [OK]databack/mysql-backup Back up mysql databases to... anywhere! 42deitch/mysql-backup REPLACED! Please use http://hub.docker.com/r… 41 [OK]prom/mysqld-exporter 37 [OK]tutum/mysql Base docker image to run a MySQL database se… 35schickling/mysql-backup-s3 Backup MySQL to S3 (supports periodic backup… 29 [OK]linuxserver/mysql A Mysql container, brought to you by LinuxSe… 27centos/mysql-56-centos7 MySQL 5.6 SQL database server 20circleci/mysql MySQL is a widely used, open-source relation… 20mysql/mysql-router MySQL Router provides transparent routing be… 19arey/mysql-client Run a MySQL client from a docker container 17 [OK]fradelg/mysql-cron-backup MySQL/MariaDB database backup using cron tas… 12 [OK]yloeffler/mysql-backup This image runs mysqldump to backup data usi… 7 [OK]openshift/mysql-55-centos7 DEPRECATED: A Centos7 based MySQL v5.5 image… 6devilbox/mysql Retagged MySQL, MariaDB and PerconaDB offici… 3ansibleplaybookbundle/mysql-apb An APB which deploys RHSCL MySQL 2 [OK]jelastic/mysql An image of the MySQL database server mainta… 1widdpim/mysql-client Dockerized MySQL Client (5.7) including Curl… 1 [OK]➜ ~ docker search --filter=stars=3000 mysqlNAME DESCRIPTION STARS OFFICIAL AUTOMATEDmysql MySQL is a widely used, open-source relation… 10743 [OK]mariadb MariaDB Server is a high performing open sou… 4046 [OK]# 重要的可以filterdocker search --filter=stars=3000 mysql docker pull 拉取 ➜ ~ docker pull mysqlUsing default tag: latest# docker 默认拉取最新的版本号latest: Pulling from library/mysqlf7ec5a41d630: Pull complete9444bb562699: Pull complete6a4207b96940: Pull complete181cefd361ce: Pull complete8a2090759d8a: Pull complete15f235e0d7ee: Pull completed870539cd9db: Pull complete5726073179b6: Pull completeeadfac8b2520: Pull completef5936a8c3f2b: Pull completecca8ee89e625: Pull complete6c79df02586a: Pull completeDigest: sha256:6e0014cdd88092545557dee5e9eb7e1a3c84c9a14ad2418d5f2231e930967a38Status: Downloaded newer image for mysql:latestdocker.io/library/mysql:latest➜ ~ docker pull mysql:5.7# 指定版本号，拉取版本号的镜像5.7: Pulling from library/mysqlf7ec5a41d630: Already exists9444bb562699: Already exists6a4207b96940: Already exists181cefd361ce: Already exists8a2090759d8a: Already exists15f235e0d7ee: Already existsd870539cd9db: Already exists## docker采用分层的思想，把一个完整的镜像拆分，如果之前下载过某些分层，则不需要重新下载7310c448ab4f: Pull complete4a72aac2e800: Pull completeb1ab932f17c4: Pull complete1a985de740ee: Pull completeDigest: sha256:e42a18d0bd0aa746a734a49cbbcc079ccdf6681c474a238d38e79dc0884e0eccStatus: Downloaded newer image for mysql:5.7docker.io/library/mysql:5.7 docker rmi -f 删除镜像 ➜ ~ docker rmi --helpUsage: docker rmi [OPTIONS] IMAGE [IMAGE...]Remove one or more imagesOptions: -f, --force Force removal of the image --no-prune Do not delete untagged parents# 删除指定的镜像➜ ~docker rmi -f daaaaaaaa# 递归删除全部镜像➜ ~docker rmi -f $(docker images -aq) 容器命令有了镜像才能有容器 docker run 运行命令 ➜ ~ docker run --helpUsage: docker run [OPTIONS] IMAGE [COMMAND] [ARG...]Run a command in a new containerOptions: --add-host list Add a custom host-to-IP mapping (host:ip) -a, --attach list Attach to STDIN, STDOUT or STDERR --blkio-weight uint16 Block IO (relative weight), between 10 and 1000, or 0 to disable (default 0) --blkio-weight-device list Block IO weight (relative device weight) (default []) --cap-add list Add Linux capabilities --cap-drop list Drop Linux capabilities --cgroup-parent string Optional parent cgroup for the container --cgroupns string Cgroup namespace to use (host|private) 'host': Run the container in the Docker host's cgroup namespace 'private': Run the container in its own private cgroup namespace '': Use the cgroup namespace as configured by the default-cgroupns-mode option on the daemon (default) --cidfile string Write the container ID to the file --cpu-period int Limit CPU CFS (Completely Fair Scheduler) period --cpu-quota int Limit CPU CFS (Completely Fair Scheduler) quota --cpu-rt-period int Limit CPU real-time period in microseconds --cpu-rt-runtime int Limit CPU real-time runtime in microseconds -c, --cpu-shares int CPU shares (relative weight) --cpus decimal Number of CPUs --cpuset-cpus string CPUs in which to allow execution (0-3, 0,1) --cpuset-mems string MEMs in which to allow execution (0-3, 0,1) -d, --detach Run container in background and print container ID --detach-keys string Override the key sequence for detaching a container --device list Add a host device to the container --device-cgroup-rule list Add a rule to the cgroup allowed devices list --device-read-bps list Limit read rate (bytes per second) from a device (default []) --device-read-iops list Limit read rate (IO per second) from a device (default []) --device-write-bps list Limit write rate (bytes per second) to a device (default []) --device-write-iops list Limit write rate (IO per second) to a device (default []) --disable-content-trust Skip image verification (default true) --dns list Set custom DNS servers --dns-option list Set DNS options --dns-search list Set custom DNS search domains --domainname string Container NIS domain name --entrypoint string Overwrite the default ENTRYPOINT of the image -e, --env list Set environment variables --env-file list Read in a file of environment variables --expose list Expose a port or a range of ports --gpus gpu-request GPU devices to add to the container ('all' to pass all GPUs) --group-add list Add additional groups to join --health-cmd string Command to run to check health --health-interval duration Time between running the check (ms|s|m|h) (default 0s) --health-retries int Consecutive failures needed to report unhealthy --health-start-period duration Start period for the container to initialize before starting health-retries countdown (ms|s|m|h) (default 0s) --health-timeout duration Maximum time to allow one check to run (ms|s|m|h) (default 0s) --help Print usage -h, --hostname string Container host name --init Run an init inside the container that forwards signals and reaps processes -i, --interactive Keep STDIN open even if not attached --ip string IPv4 address (e.g., 172.30.100.104) --ip6 string IPv6 address (e.g., 2001:db8::33) --ipc string IPC mode to use --isolation string Container isolation technology --kernel-memory bytes Kernel memory limit -l, --label list Set meta data on a container --label-file list Read in a line delimited file of labels --link list Add link to another container --link-local-ip list Container IPv4/IPv6 link-local addresses --log-driver string Logging driver for the container --log-opt list Log driver options --mac-address string Container MAC address (e.g., 92:d0:c6:0a:29:33) -m, --memory bytes Memory limit --memory-reservation bytes Memory soft limit --memory-swap bytes Swap limit equal to memory plus swap: '-1' to enable unlimited swap --memory-swappiness int Tune container memory swappiness (0 to 100) (default -1) --mount mount Attach a filesystem mount to the container --name string Assign a name to the container --network network Connect a container to a network --network-alias list Add network-scoped alias for the container --no-healthcheck Disable any container-specified HEALTHCHECK --oom-kill-disable Disable OOM Killer --oom-score-adj int Tune host's OOM preferences (-1000 to 1000) --pid string PID namespace to use --pids-limit int Tune container pids limit (set -1 for unlimited) --platform string Set platform if server is multi-platform capable --privileged Give extended privileges to this container -p, --publish list Publish a container's port(s) to the host -P, --publish-all Publish all exposed ports to random ports --pull string Pull image before running (&quot;always&quot;|&quot;missing&quot;|&quot;never&quot;) (default &quot;missing&quot;) --read-only Mount the container's root filesystem as read only --restart string Restart policy to apply when a container exits (default &quot;no&quot;) --rm Automatically remove the container when it exits --runtime string Runtime to use for this container --security-opt list Security Options --shm-size bytes Size of /dev/shm --sig-proxy Proxy received signals to the process (default true) --stop-signal string Signal to stop a container (default &quot;SIGTERM&quot;) --stop-timeout int Timeout (in seconds) to stop a container --storage-opt list Storage driver options for the container --sysctl map Sysctl options (default map[]) --tmpfs list Mount a tmpfs directory -t, --tty Allocate a pseudo-TTY --ulimit ulimit Ulimit options (default []) -u, --user string Username or UID (format: &lt;name|uid&gt;[:&lt;group|gid&gt;]) --userns string User namespace to use --uts string UTS namespace to use -v, --volume list Bind mount a volume --volume-driver string Optional volume driver for the container --volumes-from list Mount volumes from the specified container(s) -w, --workdir string Working directory inside the container 下面我们拿几个常用的参数解释 --name 指定运行容器的名字-d 后台方式-it 使用交互方式 进入容器查看-p 指定容器的端口-P 随机指定端口 测试一下 ➜ ~ docker run --name centos1 -itd 300e315adb2fc1c9a9a26dd33a6392487db1f2a7c960332eac309413a4fa82e9d9f30b4ec3fe➜ ~ docker psCONTAINER ID IMAGE COMMAND CREATED STATUS PORTS NAMESc1c9a9a26dd3 300e315adb2f &quot;/bin/bash&quot; 5 seconds ago Up 4 seconds centos1➜ ~ docker exec -it centos1 /bin/bash[root@c1c9a9a26dd3 /]# lsbin dev etc home lib lib64 lost+found media mnt opt proc root run sbin srv sys tmp usr var[root@c1c9a9a26dd3 /]# pwd/[root@c1c9a9a26dd3 /]# whereis nginxnginx: docker ps 列出运行的容器 ➜ ~ docker psCONTAINER ID IMAGE COMMAND CREATED STATUS PORTS NAMESc1c9a9a26dd3 300e315adb2f &quot;/bin/bash&quot; 21 hours ago Up 21 hours centos1➜ ~ docker ps -aCONTAINER ID IMAGE COMMAND CREATED STATUS PORTS NAMESc1c9a9a26dd3 300e315adb2f &quot;/bin/bash&quot; 21 hours ago Up 21 hours centos1b20cb371f580 d1165f221234 &quot;/hello&quot; 4 days ago Exited (0) 4 days ago boring_lederberg056de2c653a8 ab2f358b8612 &quot;docker-entrypoint.s…&quot; 3 months ago Exited (255) 3 months ago 0.0.0.0:3306-&gt;3306/tcp, 33060/tcp mysql5394243f1574 zookeeper:latest &quot;/docker-entrypoint.…&quot; 4 months ago Exited (255) 4 days ago 2888/tcp, 3888/tcp, 8080/tcp, 0.0.0.0:12181-&gt;2181/tcp zk154a9912b99e1 redis:latest &quot;docker-entrypoint.s…&quot; 6 months ago Exited (255) 6 months ago 0.0.0.0:36379-&gt;6379/tcp redis-slaver22ce7cec87780 redis:latest &quot;docker-entrypoint.s…&quot; 6 months ago Exited (255) 3 months ago 0.0.0.0:16379-&gt;6379/tcp redis-master51606ec8b03a redis:latest &quot;docker-entrypoint.s…&quot; 6 months ago Exited (255) 5 weeks ago 0.0.0.0:26379-&gt;6379/tcp redis-slaver14113a977a62f nginx:latest &quot;/docker-entrypoint.…&quot; 6 months ago Exited (255) 6 months ago 0.0.0.0:80-&gt;80/tcp nginx-load-balancec99db3188f9a 9b9cb95443b5 &quot;/bin/echo 'Hello wo…&quot; 6 months ago Exited (0) 6 months ago dreamy_shockley1522138f775a 9b9cb95443b5 &quot;/bin/echo 'Hello wo…&quot; 6 months ago Exited (0) 6 months ago pensive_cartwrightc82cd778a8bc 9b9cb95443b5 &quot;/bin/echo 'Hello wo…&quot; 6 months ago Exited (0) 6 months ago flamboyant_nightingale docker rm 容器id（删除容器） docker rm -f 容器iddocker rm 容器id 容器的其他命令 docker start 容器iddocker restart 重启容器iddocker stop 容器iddocker kill 容器id docker 查看日志 docker logs -tf -n 20 c1c9a9a26dd3 docker 查看元数据 ➜ Shell docker inspect centos1[ { &quot;Id&quot;: &quot;c1c9a9a26dd33a6392487db1f2a7c960332eac309413a4fa82e9d9f30b4ec3fe&quot;, &quot;Created&quot;: &quot;2021-04-14T14:41:47.9653797Z&quot;, &quot;Path&quot;: &quot;/bin/bash&quot;, &quot;Args&quot;: [], &quot;State&quot;: { &quot;Status&quot;: &quot;running&quot;, &quot;Running&quot;: true, &quot;Paused&quot;: false, &quot;Restarting&quot;: false, &quot;OOMKilled&quot;: false, &quot;Dead&quot;: false, &quot;Pid&quot;: 3193, &quot;ExitCode&quot;: 0, &quot;Error&quot;: &quot;&quot;, &quot;StartedAt&quot;: &quot;2021-04-16T09:00:21.3049137Z&quot;, &quot;FinishedAt&quot;: &quot;2021-04-16T01:39:43.8417964Z&quot; }, &quot;Image&quot;: &quot;sha256:300e315adb2f96afe5f0b2780b87f28ae95231fe3bdd1e16b9ba606307728f55&quot;, &quot;ResolvConfPath&quot;: &quot;/var/lib/docker/containers/c1c9a9a26dd33a6392487db1f2a7c960332eac309413a4fa82e9d9f30b4ec3fe/resolv.conf&quot;, &quot;HostnamePath&quot;: &quot;/var/lib/docker/containers/c1c9a9a26dd33a6392487db1f2a7c960332eac309413a4fa82e9d9f30b4ec3fe/hostname&quot;, &quot;HostsPath&quot;: &quot;/var/lib/docker/containers/c1c9a9a26dd33a6392487db1f2a7c960332eac309413a4fa82e9d9f30b4ec3fe/hosts&quot;, &quot;LogPath&quot;: &quot;/var/lib/docker/containers/c1c9a9a26dd33a6392487db1f2a7c960332eac309413a4fa82e9d9f30b4ec3fe/c1c9a9a26dd33a6392487db1f2a7c960332eac309413a4fa82e9d9f30b4ec3fe-json.log&quot;, &quot;Name&quot;: &quot;/centos1&quot;, &quot;RestartCount&quot;: 0, &quot;Driver&quot;: &quot;overlay2&quot;, &quot;Platform&quot;: &quot;linux&quot;, &quot;MountLabel&quot;: &quot;&quot;, &quot;ProcessLabel&quot;: &quot;&quot;, &quot;AppArmorProfile&quot;: &quot;&quot;, &quot;ExecIDs&quot;: null, &quot;HostConfig&quot;: { &quot;Binds&quot;: null, &quot;ContainerIDFile&quot;: &quot;&quot;, &quot;LogConfig&quot;: { &quot;Type&quot;: &quot;json-file&quot;, &quot;Config&quot;: {} }, &quot;NetworkMode&quot;: &quot;default&quot;, &quot;PortBindings&quot;: {}, &quot;RestartPolicy&quot;: { &quot;Name&quot;: &quot;no&quot;, &quot;MaximumRetryCount&quot;: 0 }, &quot;AutoRemove&quot;: false, &quot;VolumeDriver&quot;: &quot;&quot;, &quot;VolumesFrom&quot;: null, &quot;CapAdd&quot;: null, &quot;CapDrop&quot;: null, &quot;CgroupnsMode&quot;: &quot;host&quot;, &quot;Dns&quot;: [], &quot;DnsOptions&quot;: [], &quot;DnsSearch&quot;: [], &quot;ExtraHosts&quot;: null, &quot;GroupAdd&quot;: null, &quot;IpcMode&quot;: &quot;private&quot;, &quot;Cgroup&quot;: &quot;&quot;, &quot;Links&quot;: null, &quot;OomScoreAdj&quot;: 0, &quot;PidMode&quot;: &quot;&quot;, &quot;Privileged&quot;: false, &quot;PublishAllPorts&quot;: false, &quot;ReadonlyRootfs&quot;: false, &quot;SecurityOpt&quot;: null, &quot;UTSMode&quot;: &quot;&quot;, &quot;UsernsMode&quot;: &quot;&quot;, &quot;ShmSize&quot;: 67108864, &quot;Runtime&quot;: &quot;runc&quot;, &quot;ConsoleSize&quot;: [ 0, 0 ], &quot;Isolation&quot;: &quot;&quot;, &quot;CpuShares&quot;: 0, &quot;Memory&quot;: 0, &quot;NanoCpus&quot;: 0, &quot;CgroupParent&quot;: &quot;&quot;, &quot;BlkioWeight&quot;: 0, &quot;BlkioWeightDevice&quot;: [], &quot;BlkioDeviceReadBps&quot;: null, &quot;BlkioDeviceWriteBps&quot;: null, &quot;BlkioDeviceReadIOps&quot;: null, &quot;BlkioDeviceWriteIOps&quot;: null, &quot;CpuPeriod&quot;: 0, &quot;CpuQuota&quot;: 0, &quot;CpuRealtimePeriod&quot;: 0, &quot;CpuRealtimeRuntime&quot;: 0, &quot;CpusetCpus&quot;: &quot;&quot;, &quot;CpusetMems&quot;: &quot;&quot;, &quot;Devices&quot;: [], &quot;DeviceCgroupRules&quot;: null, &quot;DeviceRequests&quot;: null, &quot;KernelMemory&quot;: 0, &quot;KernelMemoryTCP&quot;: 0, &quot;MemoryReservation&quot;: 0, &quot;MemorySwap&quot;: 0, &quot;MemorySwappiness&quot;: null, &quot;OomKillDisable&quot;: false, &quot;PidsLimit&quot;: null, &quot;Ulimits&quot;: null, &quot;CpuCount&quot;: 0, &quot;CpuPercent&quot;: 0, &quot;IOMaximumIOps&quot;: 0, &quot;IOMaximumBandwidth&quot;: 0, &quot;MaskedPaths&quot;: [ &quot;/proc/asound&quot;, &quot;/proc/acpi&quot;, &quot;/proc/kcore&quot;, &quot;/proc/keys&quot;, &quot;/proc/latency_stats&quot;, &quot;/proc/timer_list&quot;, &quot;/proc/timer_stats&quot;, &quot;/proc/sched_debug&quot;, &quot;/proc/scsi&quot;, &quot;/sys/firmware&quot; ], &quot;ReadonlyPaths&quot;: [ &quot;/proc/bus&quot;, &quot;/proc/fs&quot;, &quot;/proc/irq&quot;, &quot;/proc/sys&quot;, &quot;/proc/sysrq-trigger&quot; ] }, &quot;GraphDriver&quot;: { &quot;Data&quot;: { &quot;LowerDir&quot;: &quot;/var/lib/docker/overlay2/274eb8c16a6e5e6ac1a68fb60adc3835a4afa20ed7882daac3b0fd928ab5d405-init/diff:/var/lib/docker/overlay2/7963fffc28e92ac68cf658653fffa8d5c6104941d91985b5ebda6a0c78cea3fd/diff&quot;, &quot;MergedDir&quot;: &quot;/var/lib/docker/overlay2/274eb8c16a6e5e6ac1a68fb60adc3835a4afa20ed7882daac3b0fd928ab5d405/merged&quot;, &quot;UpperDir&quot;: &quot;/var/lib/docker/overlay2/274eb8c16a6e5e6ac1a68fb60adc3835a4afa20ed7882daac3b0fd928ab5d405/diff&quot;, &quot;WorkDir&quot;: &quot;/var/lib/docker/overlay2/274eb8c16a6e5e6ac1a68fb60adc3835a4afa20ed7882daac3b0fd928ab5d405/work&quot; }, &quot;Name&quot;: &quot;overlay2&quot; }, &quot;Mounts&quot;: [], &quot;Config&quot;: { &quot;Hostname&quot;: &quot;c1c9a9a26dd3&quot;, &quot;Domainname&quot;: &quot;&quot;, &quot;User&quot;: &quot;&quot;, &quot;AttachStdin&quot;: false, &quot;AttachStdout&quot;: false, &quot;AttachStderr&quot;: false, &quot;Tty&quot;: true, &quot;OpenStdin&quot;: true, &quot;StdinOnce&quot;: false, &quot;Env&quot;: [ &quot;PATH=/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin&quot; ], &quot;Cmd&quot;: [ &quot;/bin/bash&quot; ], &quot;Image&quot;: &quot;300e315adb2f&quot;, &quot;Volumes&quot;: null, &quot;WorkingDir&quot;: &quot;&quot;, &quot;Entrypoint&quot;: null, &quot;OnBuild&quot;: null, &quot;Labels&quot;: { &quot;org.label-schema.build-date&quot;: &quot;20201204&quot;, &quot;org.label-schema.license&quot;: &quot;GPLv2&quot;, &quot;org.label-schema.name&quot;: &quot;CentOS Base Image&quot;, &quot;org.label-schema.schema-version&quot;: &quot;1.0&quot;, &quot;org.label-schema.vendor&quot;: &quot;CentOS&quot; } }, &quot;NetworkSettings&quot;: { &quot;Bridge&quot;: &quot;&quot;, &quot;SandboxID&quot;: &quot;49205c904c996ac8534688930c458ed478263ec01a9553322f3f9bfc53502631&quot;, &quot;HairpinMode&quot;: false, &quot;LinkLocalIPv6Address&quot;: &quot;&quot;, &quot;LinkLocalIPv6PrefixLen&quot;: 0, &quot;Ports&quot;: {}, &quot;SandboxKey&quot;: &quot;/var/run/docker/netns/49205c904c99&quot;, &quot;SecondaryIPAddresses&quot;: null, &quot;SecondaryIPv6Addresses&quot;: null, &quot;EndpointID&quot;: &quot;54be23afbd52e46a0d8570f6f4ff68b2b2b33f186728c161baa1f6f0b3bfa9db&quot;, &quot;Gateway&quot;: &quot;172.17.0.1&quot;, &quot;GlobalIPv6Address&quot;: &quot;&quot;, &quot;GlobalIPv6PrefixLen&quot;: 0, &quot;IPAddress&quot;: &quot;172.17.0.2&quot;, &quot;IPPrefixLen&quot;: 16, &quot;IPv6Gateway&quot;: &quot;&quot;, &quot;MacAddress&quot;: &quot;02:42:ac:11:00:02&quot;, &quot;Networks&quot;: { &quot;bridge&quot;: { &quot;IPAMConfig&quot;: null, &quot;Links&quot;: null, &quot;Aliases&quot;: null, &quot;NetworkID&quot;: &quot;6226106a822b92267889ded6757eab78f6165c65aa638e373c3ae472efe73c86&quot;, &quot;EndpointID&quot;: &quot;54be23afbd52e46a0d8570f6f4ff68b2b2b33f186728c161baa1f6f0b3bfa9db&quot;, &quot;Gateway&quot;: &quot;172.17.0.1&quot;, &quot;IPAddress&quot;: &quot;172.17.0.2&quot;, &quot;IPPrefixLen&quot;: 16, &quot;IPv6Gateway&quot;: &quot;&quot;, &quot;GlobalIPv6Address&quot;: &quot;&quot;, &quot;GlobalIPv6PrefixLen&quot;: 0, &quot;MacAddress&quot;: &quot;02:42:ac:11:00:02&quot;, &quot;DriverOpts&quot;: null } } } }] docker 查看进程 docker top containt 进入当前的容器 docker exec -it centos1 /bin/bash# 方式二docker attach centos1 从容器中copy #从docker中往外拷贝文件docker cp 容器id:/test.txt ./ 制作自己的容器 ➜ Shell docker commit -m='我自己的centos' -a='mrhy' c1c9a9a26dd3 centos-my:1.0sha256:c3349319374d0630c0a70afa4a3bf7de8c31385f40e60b145d786eb1969e97d6➜ Shell docker imagesREPOSITORY TAG IMAGE ID CREATED SIZEcentos-my 1.0 c3349319374d 2 minutes ago 209MBmysql 5.7 450379344707 7 days ago 449MBmysql latest cbe8815cbea8 7 days ago 546MBcentos latest 300e315adb2f 4 months ago 209MBzookeeper latest ea93faa92337 4 months ago 253MBredis latest 84c5f6e03bf0 7 months ago 104MBnginx latest 7e4d58f0e5f3 7 months ago 133MBbde2020/hive latest a65dc394c508 2 years ago 1.17GB docker 挂载卷 docker run -d -p 3306:3306 --name mysql-master -v=/Users/mrhy/environment/mysql/master/config/my.cnf:/etc/my.cnf -v=/Users/mrhy/environment/mysql/master/data:/var/lib/mysql -e MYSQL_ROOT_PASSWORD=*** --privileged=true mysql:5.7 -v 指的挂载当前文件: 容器内部文件 docker技巧 docker容器访问宿主机的地址 宿主机地址为：host.docker.internal","link":"/docker-command/"}],"tags":[{"name":"spring","slug":"spring","link":"/tags/spring/"},{"name":"java","slug":"java","link":"/tags/java/"},{"name":"jvm","slug":"jvm","link":"/tags/jvm/"},{"name":"设计模式","slug":"设计模式","link":"/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"},{"name":"docker","slug":"docker","link":"/tags/docker/"},{"name":"mysql","slug":"mysql","link":"/tags/mysql/"},{"name":"大数据","slug":"大数据","link":"/tags/%E5%A4%A7%E6%95%B0%E6%8D%AE/"},{"name":"flink","slug":"flink","link":"/tags/flink/"},{"name":"clickhouse","slug":"clickhouse","link":"/tags/clickhouse/"},{"name":"剑指offer","slug":"剑指offer","link":"/tags/%E5%89%91%E6%8C%87offer/"},{"name":"源码","slug":"源码","link":"/tags/%E6%BA%90%E7%A0%81/"}],"categories":[]}